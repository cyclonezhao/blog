<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一元n次方程]]></title>
    <url>%2Fblog%2F%E4%B8%80%E5%85%83n%E6%AC%A1%E6%96%B9%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1. 一元二次方程形如 \(f(x) = ax^2 + bx + c\) 称作一元二次方程，即自变量只有一个，自变量的最高次数为2。 1.1. 根的性质想求 \(f(x) = ax^2 + bx + c = 0\) 的根，有一个思路：先将表达式 \(ax^2 + bx + c = 0\) 转成 \((x+A)^2=B\) 的形式，之后即可得 \(x=\pm \sqrt{B}-A\) 。而 \((x+A)^2 = x^2 + 2Ax + A^2\) ，所以先将 \(ax^2 + bx + c = 0\) 转化成这种形式，推导过程如下：消除二次项系数 x^2 + \frac{b}{a}x + \frac{c}{a} = 0即 x^2 + \frac{b}{a}x = -\frac{c}{a}等号两边同时加项，将左边构造成 \(x^2 + 2Ax + A^2\) 的形式 x^2 + \frac{b}{2a}x\cdot 2 + (\frac{b}{2a})^2 = -\frac{c}{a}-(\frac{b}{2a})^2左边变形，右边同分母相加 (x+\frac{b}{2a})^2 = \frac{-4ac+b^2}{4a^2}求得 x=\pm \sqrt{\frac{b^2-4ac}{4a^2}} - \frac{b}{2a} = \frac{-b\pm\sqrt{b^2-4ac}}{2a}1.2. 抛物线性质由以上结果可知，抛物线基于 \(x=-\frac{b}{2a}\) 对称，将该值代入方程，得原点坐标为 \((-\frac{b}{2a},\frac{-b^2+4ac}{4a})\) 。 1.3. 判别式在根表达式中， \(\Delta = b^2-4ac\) 为判别式，可根据判别式的值大于、等于、小于0的情况，判断方程有两个实根，一个实根还是有两个共轭复根。 2. 韦达定理2.1. 定义如果方程 $f(x) = a_0x^n+a_1x^{n-1}+…+a_{n-1}x+a_n=0$ $(a_0\neq 0)$ 的n个根是 $x_1,x_2,…,x_{n-1},x_n$，那么 \begin{cases} x_1+x_2+\cdot\cdot\cdot+x_n = -\frac{a_1}{a_0},\\ x_1x_2+x_1x_3+\cdot\cdot\cdot+x_{n-1}x_n = \frac{a_2}{a_0},\\ \cdot\cdot\cdot\\ x_1x_2x_3 \cdot\cdot\cdot x_{n-1}x_n = (-1)^n\frac{a_n}{a_0}. \end{cases}2.2. 证明据书上1所说，因为 $x_1, x_2, \cdot\cdot\cdot, x_n$ 是 $f(x)=0$ 的根，所以 $f(x)$ 必定含有n个一次因式：$x-x_1, x-x_2, \cdot\cdot\cdot, x-x_{n-1}, x-x_n$ 并且$f(x) = a_0(x-x_1)(x-x_2) \cdot\cdot\cdot (x-x_{n-1})(x-x_n)$2 把上式右端按照$x$降幂展开得 a_0x^n+a_1x^{n-1}+...+a_{n-1}x+a_n =\\ a_0x^n-a_0(x_1+x_2+\cdot\cdot\cdot+x_n)x^{n-1} \\ +a_0(x_1x_2+x_1x_3+\cdot\cdot\cdot+x_{n-1}x_n)x^{n-2}\\ +\cdot\cdot\cdot+(-1)^na_0x_1x_2x_3\cdot\cdot\cdot x_{n-1}x_n这是一个恒等式，根据多项式恒等定理，得\begin{cases}a_1=-a_0(x_1+x_2+\cdot\cdot\cdot+x_n) \\a_2=-a_0(x_1x_2+x_1x_3+\cdot\cdot\cdot+x_{n-1}x_n) \\\cdot\cdot\cdot \\a_n=(-1)^na_0x_1x_2x_3 \cdot\cdot\cdot x_{n-1}x_n\end{cases} 故定理得证 \begin{cases} x_1+x_2+\cdot\cdot\cdot+x_n = -\frac{a_1}{a_0},\\ x_1x_2+x_1x_3+\cdot\cdot\cdot+x_{n-1}x_n = \frac{a_2}{a_0},\\ \cdot\cdot\cdot\\ x_1x_2x_3 \cdot\cdot\cdot x_{n-1}x_n = (-1)^n\frac{a_n}{a_0}. \end{cases}3. 方程变换3.1. 变换后各个根为原方程各个根的k倍定理：方程 $ f(\frac{y}{k}) = 0 $ 的各个根分别等于方程 $ f(x) = 0 $ 各个根的k倍。证明：设 $ a_i(i=1,2,\cdot\cdot\cdot , n) $ 是方程 $ f(x) = 0 $ 的根，则 $ f(a_i) = f(\frac{ka_i}{k}) = 0 $，所以 $ ka_i(i=1,2,\cdot\cdot\cdot , n) $ 是方程 $ f(\frac{y}{k}) = 0 $ 的根，又因为 $ f(\frac{y}{k}) = 0 $ 只有n个根，故 $ f(\frac{y}{k}) = 0 $ 的各根分别等于 $ f(x) = 0 $ 各根的k倍。 3.2. 变换后各个根为原方程各个根相差k$f(y+k)=0$ 的各个根分别等于方程 $ f(x) = 0 $ 的各个根减去k。 3.3. 变换后各个根为原方程各个根的倒数$f(\frac{1}{y})$ 的各个根分别等于方程 $ f(x) = 0 $ 的各个根的倒数。 3.3.1. 倒根方程如果n次方程 $g(x)$ 的各个根分别是n次方程 $f(x) = a_0x^n+a_1x^{n-1}+…+a_{n-1}x+a_n=0$ 各个根的倒数，那么 $g(x) = a_nx^n+a_{n-1}x^{n-1}+…+a_1x+a_0=0$。 1.《初等数学研究》（主编：叶立军）第3.3节 ↩2.这里我能理解当x取这些根值的其中之一时，等式的左右两边都为0，但我还不明白为啥据此能得出 $f(x)$ 一定有这n个因式，且这条等式（不管x取什么值都）成立，这个问题先放着。 ↩]]></content>
      <categories>
        <category>数学</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ch02-智能Agent]]></title>
    <url>%2Fblog%2Fch02-%E6%99%BA%E8%83%BDAgent%2F</url>
    <content type="text"><![CDATA[性能度量行动序列 Agent一词的定义]]></content>
      <categories>
        <category>AI</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ch03-通过搜索进行问题求解]]></title>
    <url>%2Fblog%2Fch03-%E9%80%9A%E8%BF%87%E6%90%9C%E7%B4%A2%E8%BF%9B%E8%A1%8C%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[要进行问题求解，首先要讨论的是对问题及其解的精确定义。目标 目标被满足的那些“世界的状态”的集合它需要确定它能完成的行动种类，和行动所带来的状态变化 问题形式化，是在给定目标下对需要采取的行动和需要考虑的状态的确认过程搜索，为达到目标，寻找行动序列的过程搜索的输入是问题，输出是问题的解，以行动序列的形式输出解 用5个组成部分形式化描述问题 Agent的初始状态 描述Agent的可能行动，即描述Agent在给定状态s下可以执行的动作集合 对每个行动的描述，称为转移模型，在状态s下执行行动a后达到的状态 目标测试，确定给定的状态是不是目标状态（在目标状态集合里） 路径耗散，解的质量由路径耗散度量，耗散值最小的为最优解 初始状态、行动和转移模型定义了问题的状态空间 八数码问题 滑块问题 NP完全问题 n皇后问题 搜索算法的测试用例]]></content>
      <categories>
        <category>AI</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式定理]]></title>
    <url>%2Fblog%2F%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. 二项式定理$(a+b)^2$可看成$(a+b)(a+b)$，即两个因式(a+b)相乘。观察它的两次乘法分配率的计算过程： (a+b)(a+b)=a\cdot a+ab+ba+b\cdot b可以这样理解：从两个因式中取出两个a相乘，得$a^2$，共有$C_2^2$个1；然后从两个因式中只取一个a（另一个就只能为b了）相乘，得$ab$，共有$C_2^1$个；最后都取b（即都不取a）相乘，共有$C_2^0$个，所以 (a+b)^2 = C_2^2a^2 + C_2^1ab + C_2^0b^2 = a^2+2ab+b^2 同样的思路： (a+b)^3 = C_3^3a^3 + C_3^2a^2b + C_3^1ab^2 + C_3^0b^3 = a^3+3a^2b+3ab^2+b^3还是同样的思路： (a+b)^n = C_n^na^n + C_n^{n-1}a^{n-1}b+C_n^{n-2}a^{n-2}b^2+\cdot\cdot\cdot+C_n^2a^2b^{n-2}+C_n^1ab^{n-1}+C_n^0b^n可以更简单的记为： (a+b)^n = \sum C_n^ma^mb^{n-m}2. 多项式定理考虑$(a+b+c)^3$，将其展开得 a \cdot a \cdot a + a \cdot a \cdot b + a \cdot a \cdot c + \cdot\cdot\cdot可以看出，展开式的每一项的次数都是3，考虑其中一项：$a \cdot a \cdot b$，这一项是两个a和一个b相乘，那么这样的项有多少个呢？有： aab aba baa 3个。所以将展开式合并同类项后，aab项的系数是3. 然后如何用更一般化的方式表示这个3呢？先将aab看成是a1,a2,b这三个不同的元素，那么它们的全排列有 $a1,a2,b$ $a2,a1,b$ $a1,b,a2$ $a2,b,a1$ $b,a1,a2$ $b,a2,a1$ 一共6个。同时 $a1,a2,b$ $a2,a1,b$ 其实是一样的，剩余4个也是同样的道理，将a1和a2看做同一个元素，它们的排列数就是$6/2$个。这一项是一个a取两次，b取1次的3个不尽相异元素的全排列，数量有$\frac{3!}{2! \cdot 1!}$个。 (a_1+a_2+ \cdot\cdot\cdot + a_m)^n = \sum\limits_{n_1+n_2+ \cdot\cdot\cdot + n_m = n} \frac{n!}{\prod\limits_{i=1}^m n_i!}\prod\limits_{i=1}^m a_i^{n_i}1.这里用到了组合的思想，见排列与组合的基本概念。 ↩]]></content>
      <categories>
        <category>数学</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排列与组合的基本概念]]></title>
    <url>%2Fblog%2F%E6%8E%92%E5%88%97%E4%B8%8E%E7%BB%84%E5%90%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[1. 加法原理做一件事情有m类方法，第一类方法中有$n_1$种方法，第二类方法中有$n_2$种方法……第m类方法中有$n_m$种方法，那么完成这件事情一共有$N=n_1+n_2+ … +n_m$种方法。 2. 乘法原理做一件事情有m个步骤，完成第一步有$n_1$种方法，完成第二步有$n_2$种方法……完成第m步有$n_m$种方法，那么完成这件事情一共有$N=n_1n_2 \cdot\cdot\cdot n_m$种方法。 3. 排列3.1. 不无重复排列从n个不同的元素中，不重复地选取m(m&lt;=n)个元素，按照一定的顺序排成一列，称为从n个不同元素中取m个元素的排列。这样取出的所有排列的个数记作$P_n^m$。 从n个元素中取m个元素，第一次取共有n种选法，第二次取共有n-1种选法，第m次取共有n-m+1种选法，根据乘法原理，有 P_n^m=n(n-1)(n-2)\cdot\cdot\cdot(n-m+1) = \frac{n!}{(n-m)!}规定，$0!=1$，$P_n^0=1$ 3.2. 可重复排列数$R_n^m=n^m$ 3.3. 不尽相异元素的全排列定义：在集合$A=\left \{ a_1,a_2,\cdot\cdot\cdot,a_n \right \}$中可重复选取m个元素。 若$a_i$可重复选取$m_i$次，且$\sum\limits_{i=1}^n m_i=m$，则这样的排列数 B_m=\frac{n!}{\prod\limits_{i=1}^n m_i!}4. 组合从n个不同的元素中，不重复地选取m(m&lt;=n)个元素并成一组，称为从n个不同元素中取m个元素的组合，相对排列而言组合不考虑元素的排列顺序，这种组合的个数记作$C_n^m$。 C_n^m=\frac{P_n^m}{P_m^m}=\frac{m!}{(n-m)!\cdot m!}可得推论： C_n^0=\frac{n!}{n!0!} = 1C_n^n=\frac{n!}{0!n!} = 1]]></content>
      <categories>
        <category>数学</category>
        <category>排列与组合</category>
      </categories>
      <tags>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本博客的搭建与维护日志]]></title>
    <url>%2Fblog%2F%E6%9C%AC%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%BB%B4%E6%8A%A4%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[1. 环境的维护1.1. 目标数据不依赖容器，数据都放在宿主机里，容器只用于跑hexo程序，容器可以随时销毁并重新创建。 1.2. 手段宿主机的根目录为/home/kduser/hexo/，容器创建命令仅映射了容器中hexo的source目录，之所以不映射整个hexo目录是因为那样会有问题，原因不明。所以在搭建环境时将除了source外其余的部分（配置文件，样式，服务端.ejs文件等）拷贝到了宿主机，以后仅修改宿主机的这些文件，并通过执行update.sh将这些文件更新到容器里并删除编译生成的public目录。 2. 维护日志2.1. 20180727 初始搭建 下载docker镜像并运行，容器起名为 hexo，指定宿主机与容器的文件映射和端口映射；PS：镜像和容器的关系就好比类与对象的关系 1sudo docker run --name hexo -it -p 80:80 -v /home/kduser/hexo/source:/usr/share/nginx/html/source simplyintricate/hexo 初始化，生成网站的一些静态文件；此处创建的文章《New Post》并不重要，仅是为了通过此命令生成初始的静态文件，这个文章后续删除掉即可 1sudo docker exec -it hexo hexo new "New Post" 该命令具有重新刷新的作用，即根据文章.md文件生成html文件 1sudo docker exec -it hexo hexo generate 将容器除source目录以外的其余部分拷贝到宿主机 123456789101112host="hexo:/usr/share/nginx/html"dest="/home/kduser/hexo"docker cp $&#123;host&#125;/50x.html $&#123;dest&#125;/docker cp $&#123;host&#125;/db.json $&#123;dest&#125;/docker cp $&#123;host&#125;/index.html $&#123;dest&#125;/docker cp $&#123;host&#125;/node_modules $&#123;dest&#125;/docker cp $&#123;host&#125;/package.json $&#123;dest&#125;/docker cp $&#123;host&#125;/public $&#123;dest&#125;/docker cp $&#123;host&#125;/scaffolds $&#123;dest&#125;/docker cp $&#123;host&#125;/themes $&#123;dest&#125;/docker cp $&#123;host&#125;/_config.yml $&#123;dest&#125;/ 2.2. 20180801 更换Next样式 从网上下载样式，解压到themes目录，并更名为next 修改_config.yml，增加配置：theme: next 2.3. 20180810 修改源码修改node_modules\hexo\lib\plugins\generator\page.js，增加以下代码，使得prototype目录下的内容不被hexo处理，原封不动地拷贝到public运行时目录。prototype目录用于放置产品原型html1234567891011var path = page.path;var notRender = ["prototype"]; // 设置不被 render 的目录var dir = path.substring(0, path.indexOf('/'));if (!layout || layout === 'false' || layout === 'off' || (notRender.indexOf(dir) &gt; -1)) &#123; return &#123; path: path, data: page.content &#125;;&#125; 2.4. 20180815 关闭动画效果修改/themes/next/_config.yml，将motion的enable设置为false 2.5. 20180818 修改源码修改node_modules\hexo\lib\plugins\generator\page.js，将20180810的修改内容改为如下：12345678var notRender = []; // 设置不被 render 的目录if(self.config.no_render)&#123; notRender = self.config.no_render.split(",");&#125;var dir = path.substring(0, path.indexOf('/'));if (!layout || layout === 'false' || layout === 'off' || (notRender.indexOf(dir) &gt; -1)) &#123; 然后修改全局的_config_yml，增加：12# 不被渲染的文件或文件夹，用,分隔no_render: prototype 本来想使用hexo-processor-copyassets插件，可惜没效果。 2.6. 20180823 修改npm源，安装hexo-footnotes插件，支持注脚，重新制作镜像修改npm源的原因是内网无法发送https请求，所以用了一个非https的源。123npm config set registry http://registry.npmjs.orgnpm config list #查看更新后的config设置npm install hexo-footnotes --save # 安装插件 尝试安装以下两个插件： hexo-heading-index，标题自动加序号 hexo-generator-searchdb，文章搜索 在外网尝试安装后，执行hexo g会报错，于是上网搜索解决方案，执行以下命令后，问题解决。123sudo npm cache clean -fsudo npm install -g nsudo n stable 但是内网执行n stable会失败，估计又是网络问题。于是尝试将外网的容器迁移到内网来，在外网机器执行命令，将容器打成.tar压缩包：1docker export -o hexo-export.tar hexo 将压缩包拷到内网后，执行命令，将压缩包转化成镜像。1docker import ./hexo-export.tar zhaoyi/hexo-export 完后，执行命令生成容器1sudo docker run --name hexo -it -p 80:80 -p 4000:4000 -v /Users/zhaoyi/Documents/GitHub/hexo/source:/usr/share/nginx/html/source zhaoyi/hexo-export /bin/bash 这里出现了和以前不一样的地方，执行上述命令后会自动进入容器，但只进入根目录，而不是像之前那样能直接进入/usr/share/nginx/html目录。上网查了下资料，可以用以下命令查看之前镜像的一些信息，但只了解到这里而已。1docker inspect simplyintricate/hexo:latest 执行以下命令启动服务，这时不能按ctrl+c退出服务，只能将终端关闭重来1hexo generate &amp;&amp; nginx -g "daemon off;" 内容变更后重新生成网站，要指定-cwd1hexo --cwd /usr/share/nginx/html g 由于有了上述两个插件，所以修改/themes/next/_config.yml，关闭右侧大纲视图的序号输出，并打开本地搜索功能12345678# Table Of Contents in the Sidebartoc: enable: true # Automatically add list number to toc. number: falselocal_search: enable: true 修改/_config.yml，增加内容1234567# 标题加序号heading_index: enable: true index_styles: "&#123;1&#125; &#123;1&#125; &#123;1&#125; &#123;1&#125; &#123;1&#125; &#123;1&#125;" connector: "." global_prefix: "" global_suffix: ". " 2.7. 20180824 超链接样式修改成蓝色在主题配置文件themes/next/_config.yml，新增配置项：123456custom_css: # the style of post body link post_body_a: enable: true normal_color: "#0593d3" hover_color: "#0477ab" next主题提供了用户自定义样式的扩展功能，我们只需要在themes/next/source/css/_custom/custom.styl里添加样式就可以新增或覆盖原来的样式。1234567891011// custom.stylif hexo-config("custom_css.post_body_a.enable") .post-body a&#123; color: convert(hexo-config("custom_css.post_body_a.normal_color")); border-bottom: none; &amp;:hover &#123; color: convert(hexo-config("custom_css.post_body_a.hover_color")); text-decoration: underline; &#125; &#125; 2.8. 20180825 生成tags和categories页按照这里的说明操作即可。按tags为例说明，categories的步骤完全一样： STEP1hexo new page tags STEP2打开 /source/tags/index.md，增加type12345---title: 标签date: 2016-06-08 16:19:38type: "tags"--- STEP3打开 /themes/next/_config.yml，找到menu，打开tags的注释，可能是这样1234567menu: home: / categories: /categories #about: /about archives: /archives tags: /tags #commonweal: /404.html 2.9. 20180826 修改hexo的渲染引擎，以便更好的支持latexhexo在渲染含有下标，大括号的公式时会存在问题，因此参考这篇文章的介绍做了些修改： 替换渲染引擎（先卸载掉旧的，再安装新的）12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save 然后修改node_modules\kramed\lib\rules\inline.js，把第11行的escape变量的值做相应的修改，取消对\,{,}的转义(escape)：12// escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/, escape: /^\\([`*\[\]()#$+\-.!_&gt;])/ 再把第20行的em变量也要做相应的修改。12// em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/ 修改themes/next/_config.yml，将math.per_page属性设为true，以后在需要支持公式的文章中应加上mathjax: true配置。 配置一键发布github按照官方文档配置好后，执行deploy命令，提示需要配置git：12git config --global user.email "you@example.com"git config --global user.name "Your Name" 配置完毕后，由于我的根目录是/blog，所以还要修改/_config.yml的root属性，否则大量文件找不到。完成后，执行hexo g -d，中途会提示输入github的用户名和密码，输入后即可完成发布。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>备忘</tag>
      </tags>
  </entry>
</search>
