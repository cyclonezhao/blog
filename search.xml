<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[八皇后问题]]></title>
    <url>%2Fblog%2F%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1. 定义在8*8棋盘上放置8个皇后，使得她们不能互相攻击，问有多少种摆法。 2. 给定一种摆法，列出所有互相攻击的棋子对 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667function willAttack(point1, point2)&#123; return point1.x == point2.x || point2.y == point1.y || (Math.abs(point1.x - point2.x) == Math.abs(point1.y - point2.y));&#125;var pointList = [ &#123;x:0, y:4&#125;, &#123;x:1, y:5&#125;, &#123;x:2, y:6&#125;, &#123;x:3, y:3&#125;, &#123;x:4, y:4&#125;, &#123;x:5, y:5&#125;, &#123;x:6, y:6&#125;, &#123;x:7, y:5&#125;];var result = [];for(var i = 0, len = pointList.length; i &lt; len; i++)&#123; var point1 = pointList[i]; for(var j = i + 1; j &lt; len; j++)&#123; var point2 = pointList[j]; if(willAttack(point1, point2))&#123; result.push([point1, point2]); &#125; &#125;&#125;console.log("count: " + result.length);for(var i in result)&#123; var pair = result[i]; console.log("(%s,%s)-&gt;(%s,%s)", pair[0].x, pair[0].y, pair[1].x, pair[1].y);&#125;/* 输入var pointList = [ &#123;x:0, y:4&#125;, &#123;x:1, y:5&#125;, &#123;x:2, y:6&#125;, &#123;x:3, y:3&#125;, &#123;x:4, y:4&#125;, &#123;x:5, y:5&#125;, &#123;x:6, y:6&#125;, &#123;x:7, y:5&#125;];输出count: 17eight queens:39 (0,4)-&gt;(1,5)eight queens:39 (0,4)-&gt;(2,6)eight queens:39 (0,4)-&gt;(4,4)eight queens:39 (1,5)-&gt;(2,6)eight queens:39 (1,5)-&gt;(3,3)eight queens:39 (1,5)-&gt;(5,5)eight queens:39 (1,5)-&gt;(7,5)eight queens:39 (2,6)-&gt;(4,4)eight queens:39 (2,6)-&gt;(6,6)eight queens:39 (3,3)-&gt;(4,4)eight queens:39 (3,3)-&gt;(5,5)eight queens:39 (3,3)-&gt;(6,6)eight queens:39 (4,4)-&gt;(5,5)eight queens:39 (4,4)-&gt;(6,6)eight queens:39 (5,5)-&gt;(6,6)eight queens:39 (5,5)-&gt;(7,5)eight queens:39 (6,6)-&gt;(7,5)*/]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一元n次方程]]></title>
    <url>%2Fblog%2F%E4%B8%80%E5%85%83n%E6%AC%A1%E6%96%B9%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1. 一元二次方程形如 \(f(x) = ax^2 + bx + c\) 称作一元二次方程，即自变量只有一个，自变量的最高次数为2。 1.1. 根的性质想求 \(f(x) = ax^2 + bx + c = 0\) 的根，有一个思路：先将表达式 \(ax^2 + bx + c = 0\) 转成 \((x+A)^2=B\) 的形式，之后即可得 \(x=\pm \sqrt{B}-A\) 。而 \((x+A)^2 = x^2 + 2Ax + A^2\) ，所以先将 \(ax^2 + bx + c = 0\) 转化成这种形式，推导过程如下：消除二次项系数 x^2 + \frac{b}{a}x + \frac{c}{a} = 0即 x^2 + \frac{b}{a}x = -\frac{c}{a}等号两边同时加项，将左边构造成 \(x^2 + 2Ax + A^2\) 的形式 x^2 + \frac{b}{2a}x\cdot 2 + (\frac{b}{2a})^2 = -\frac{c}{a}-(\frac{b}{2a})^2左边变形，右边同分母相加 (x+\frac{b}{2a})^2 = \frac{-4ac+b^2}{4a^2}求得 x=\pm \sqrt{\frac{b^2-4ac}{4a^2}} - \frac{b}{2a} = \frac{-b\pm\sqrt{b^2-4ac}}{2a}1.2. 抛物线性质由以上结果可知，抛物线基于 \(x=-\frac{b}{2a}\) 对称，将该值代入方程，得原点坐标为 \((-\frac{b}{2a},\frac{-b^2+4ac}{4a})\) 。 1.3. 判别式在根表达式中， \(\Delta = b^2-4ac\) 为判别式，可根据判别式的值大于、等于、小于0的情况，判断方程有两个实根，一个实根还是有两个共轭复根。 2. 韦达定理2.1. 定义如果方程 $f(x) = a_0x^n+a_1x^{n-1}+…+a_{n-1}x+a_n=0$ $(a_0\neq 0)$ 的n个根是 $x_1,x_2,…,x_{n-1},x_n$，那么 \begin{cases} x_1+x_2+\cdot\cdot\cdot+x_n = -\frac{a_1}{a_0},\\ x_1x_2+x_1x_3+\cdot\cdot\cdot+x_{n-1}x_n = \frac{a_2}{a_0},\\ \cdot\cdot\cdot\\ x_1x_2x_3 \cdot\cdot\cdot x_{n-1}x_n = (-1)^n\frac{a_n}{a_0}. \end{cases}2.2. 证明据书上1所说，因为 $x_1, x_2, \cdot\cdot\cdot, x_n$ 是 $f(x)=0$ 的根，所以 $f(x)$ 必定含有n个一次因式：$x-x_1, x-x_2, \cdot\cdot\cdot, x-x_{n-1}, x-x_n$ 并且$f(x) = a_0(x-x_1)(x-x_2) \cdot\cdot\cdot (x-x_{n-1})(x-x_n)$2 把上式右端按照$x$降幂展开得 a_0x^n+a_1x^{n-1}+...+a_{n-1}x+a_n =\\ a_0x^n-a_0(x_1+x_2+\cdot\cdot\cdot+x_n)x^{n-1} \\ +a_0(x_1x_2+x_1x_3+\cdot\cdot\cdot+x_{n-1}x_n)x^{n-2}\\ +\cdot\cdot\cdot+(-1)^na_0x_1x_2x_3\cdot\cdot\cdot x_{n-1}x_n这是一个恒等式，根据多项式恒等定理，得\begin{cases}a_1=-a_0(x_1+x_2+\cdot\cdot\cdot+x_n) \\a_2=-a_0(x_1x_2+x_1x_3+\cdot\cdot\cdot+x_{n-1}x_n) \\\cdot\cdot\cdot \\a_n=(-1)^na_0x_1x_2x_3 \cdot\cdot\cdot x_{n-1}x_n\end{cases} 故定理得证 \begin{cases} x_1+x_2+\cdot\cdot\cdot+x_n = -\frac{a_1}{a_0},\\ x_1x_2+x_1x_3+\cdot\cdot\cdot+x_{n-1}x_n = \frac{a_2}{a_0},\\ \cdot\cdot\cdot\\ x_1x_2x_3 \cdot\cdot\cdot x_{n-1}x_n = (-1)^n\frac{a_n}{a_0}. \end{cases}3. 方程变换3.1. 变换后各个根为原方程各个根的k倍定理：方程 $ f(\frac{y}{k}) = 0 $ 的各个根分别等于方程 $ f(x) = 0 $ 各个根的k倍。证明：设 $ a_i(i=1,2,\cdot\cdot\cdot , n) $ 是方程 $ f(x) = 0 $ 的根，则 $ f(a_i) = f(\frac{ka_i}{k}) = 0 $，所以 $ ka_i(i=1,2,\cdot\cdot\cdot , n) $ 是方程 $ f(\frac{y}{k}) = 0 $ 的根，又因为 $ f(\frac{y}{k}) = 0 $ 只有n个根，故 $ f(\frac{y}{k}) = 0 $ 的各根分别等于 $ f(x) = 0 $ 各根的k倍。 3.2. 变换后各个根为原方程各个根相差k$f(y+k)=0$ 的各个根分别等于方程 $ f(x) = 0 $ 的各个根减去k。 3.3. 变换后各个根为原方程各个根的倒数$f(\frac{1}{y})$ 的各个根分别等于方程 $ f(x) = 0 $ 的各个根的倒数。 3.3.1. 倒根方程如果n次方程 $g(x)$ 的各个根分别是n次方程 $f(x) = a_0x^n+a_1x^{n-1}+…+a_{n-1}x+a_n=0$ 各个根的倒数，那么 $g(x) = a_nx^n+a_{n-1}x^{n-1}+…+a_1x+a_0=0$。 1.《初等数学研究》（主编：叶立军）第3.3节 ↩2.这里我能理解当x取这些根值的其中之一时，等式的左右两边都为0，但我还不明白为啥据此能得出 $f(x)$ 一定有这n个因式，且这条等式（不管x取什么值都）成立，这个问题先放着。 ↩]]></content>
      <categories>
        <category>数学</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ch03-通过搜索进行问题求解]]></title>
    <url>%2Fblog%2Fch03-%E9%80%9A%E8%BF%87%E6%90%9C%E7%B4%A2%E8%BF%9B%E8%A1%8C%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[要进行问题求解，首先要讨论的是对问题及其解的精确定义。目标 目标被满足的那些“世界的状态”的集合它需要确定它能完成的行动种类，和行动所带来的状态变化 问题形式化，是在给定目标下对需要采取的行动和需要考虑的状态的确认过程是一种抽象，一种化简，例如不考虑听收音机，欣赏窗外的景色搜索，为达到目标，寻找行动序列的过程搜索的输入是问题，输出是问题的解，以行动序列的形式输出解 无视环境，开环系统 用5个组成部分形式化描述问题 Agent的初始状态 描述Agent的可能行动，即描述Agent在给定状态s下可以执行的动作集合 对每个行动的描述，称为 转移模型，在状态s下执行行动a后达到的状态，用RESULT(s, a)函数描述，例如 RESULT(in(1), go(2)) = in(2) 目标测试，确定给定的状态是不是目标状态（在目标状态集合里） 路径耗散，解的质量由路径耗散度量，耗散值最小的为最优解 初始状态、行动和转移模型定义了问题的状态空间 搜索算法将状态和行动视为原子，不考虑其内部的结构 TREE-SEARCH算法考虑所有的可能来寻找一个解，GRAPH-SEARCH会考虑避免冗余路径 玩具问题 八数码问题 滑块问题 NP完全问题 n皇后问题 搜索算法的测试用例 寻径问题 旅行商问题（TSP），旅行商算法 VLSI布线问题 单元布局，通道布线 机器人导航 自动装配序列 蛋白质设计问题 扩展 problem{ RESULT(state, action): new state, STEP-COST(state, action)} 区分结点和状态两个概念用队列存储结点评价一个算法的性能需要考虑的四个方面： 完备性： 当问题有解时，算法能否保证找到解 最优性 空间复杂度 时间复杂度 问题的难度规模，状态空间图 V+E 顶点、边的集合复杂度通常由3个量表达：b，分支因子；d，目标节点最小深度；m，状态空间中任何路径的最大长度 评价算法的有效性，总代价=搜索代价+解代价 无信息搜索：也叫盲目搜索，指的是除了问题定义之外，没有更多的信息输入；搜索算法要做的是生成后继，并区分目标状态和非目标状态。有信息搜索，或者启发式搜索：知道一个非目标状态是否“更有希望”接近目标的策略 宽度优先搜索 一致代价搜索 深度优先搜索 深度受限搜索 有信息搜索，启发式函数h(n)，估算从n到目标的解代价最佳优先搜索根据评估函数选择扩展结点贪婪最佳优先搜索，扩展h(n)最小的结点，不是最优，但效率最高A搜索，扩展g(n)+h(n)最小的结点；如果h(n)是可采纳的（对于TREE-SEARCH)，或者一致的（对于GRAPH-SEARCH)，A算是完备且是最优的；它的空间复杂度很高。RBFS（递归最佳优先）和SMA（简单内存受限A），鲁棒的，最优的搜索算法；它们使用有限的内存，只要时间充足，能解决A*因内存不足不能求解的问题。 启发式搜索算法的性能取决于启发式函数的质量。]]></content>
      <categories>
        <category>AI</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ch02-智能Agent]]></title>
    <url>%2Fblog%2Fch02-%E6%99%BA%E8%83%BDAgent%2F</url>
    <content type="text"><![CDATA[性能度量行动序列 Agent一词的定义]]></content>
      <categories>
        <category>AI</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式定理]]></title>
    <url>%2Fblog%2F%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. 二项式定理$(a+b)^2$可看成$(a+b)(a+b)$，即两个因式(a+b)相乘。观察它的两次乘法分配率的计算过程： (a+b)(a+b)=a\cdot a+ab+ba+b\cdot b可以这样理解：从两个因式中取出两个a相乘，得$a^2$，共有$C_2^2$个1；然后从两个因式中只取一个a（另一个就只能为b了）相乘，得$ab$，共有$C_2^1$个；最后都取b（即都不取a）相乘，共有$C_2^0$个，所以 (a+b)^2 = C_2^2a^2 + C_2^1ab + C_2^0b^2 = a^2+2ab+b^2 同样的思路： (a+b)^3 = C_3^3a^3 + C_3^2a^2b + C_3^1ab^2 + C_3^0b^3 = a^3+3a^2b+3ab^2+b^3还是同样的思路： (a+b)^n = C_n^na^n + C_n^{n-1}a^{n-1}b+C_n^{n-2}a^{n-2}b^2+\cdot\cdot\cdot+C_n^2a^2b^{n-2}+C_n^1ab^{n-1}+C_n^0b^n可以更简单的记为： (a+b)^n = \sum C_n^ma^mb^{n-m}2. 多项式定理考虑$(a+b+c)^3$，将其展开得 a \cdot a \cdot a + a \cdot a \cdot b + a \cdot a \cdot c + \cdot\cdot\cdot可以看出，展开式的每一项的次数都是3，考虑其中一项：$a \cdot a \cdot b$，这一项是两个a和一个b相乘，那么这样的项有多少个呢？有： aab aba baa 3个。所以将展开式合并同类项后，aab项的系数是3. 然后如何用更一般化的方式表示这个3呢？先将aab看成是a1,a2,b这三个不同的元素，那么它们的全排列有 $a1,a2,b$ $a2,a1,b$ $a1,b,a2$ $a2,b,a1$ $b,a1,a2$ $b,a2,a1$ 一共6个。同时 $a1,a2,b$ $a2,a1,b$ 其实是一样的，剩余4个也是同样的道理，将a1和a2看做同一个元素，它们的排列数就是$6/2$个。这一项是一个a取两次，b取1次的3个不尽相异元素的全排列，数量有$\frac{3!}{2! \cdot 1!}$个。 (a_1+a_2+ \cdot\cdot\cdot + a_m)^n = \sum\limits_{n_1+n_2+ \cdot\cdot\cdot + n_m = n} \frac{n!}{\prod\limits_{i=1}^m n_i!}\prod\limits_{i=1}^m a_i^{n_i}1.这里用到了组合的思想，见排列与组合的基本概念。 ↩]]></content>
      <categories>
        <category>数学</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排列与组合的基本概念]]></title>
    <url>%2Fblog%2F%E6%8E%92%E5%88%97%E4%B8%8E%E7%BB%84%E5%90%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[1. 加法原理做一件事情有m类方法，第一类方法中有$n_1$种方法，第二类方法中有$n_2$种方法……第m类方法中有$n_m$种方法，那么完成这件事情一共有$N=n_1+n_2+ … +n_m$种方法。 2. 乘法原理做一件事情有m个步骤，完成第一步有$n_1$种方法，完成第二步有$n_2$种方法……完成第m步有$n_m$种方法，那么完成这件事情一共有$N=n_1n_2 \cdot\cdot\cdot n_m$种方法。 3. 排列3.1. 不无重复排列从n个不同的元素中，不重复地选取m(m&lt;=n)个元素，按照一定的顺序排成一列，称为从n个不同元素中取m个元素的排列。这样取出的所有排列的个数记作$P_n^m$。 从n个元素中取m个元素，第一次取共有n种选法，第二次取共有n-1种选法，第m次取共有n-m+1种选法，根据乘法原理，有 P_n^m=n(n-1)(n-2)\cdot\cdot\cdot(n-m+1) = \frac{n!}{(n-m)!}规定，$0!=1$，$P_n^0=1$ 3.2. 可重复排列数$R_n^m=n^m$ 3.3. 不尽相异元素的全排列定义：在集合$A=\left \{ a_1,a_2,\cdot\cdot\cdot,a_n \right \}$中可重复选取m个元素。 若$a_i$可重复选取$m_i$次，且$\sum\limits_{i=1}^n m_i=m$，则这样的排列数 B_m=\frac{n!}{\prod\limits_{i=1}^n m_i!}4. 组合从n个不同的元素中，不重复地选取m(m&lt;=n)个元素并成一组，称为从n个不同元素中取m个元素的组合，相对排列而言组合不考虑元素的排列顺序，这种组合的个数记作$C_n^m$。 C_n^m=\frac{P_n^m}{P_m^m}=\frac{m!}{(n-m)!\cdot m!}可得推论： C_n^0=\frac{n!}{n!0!} = 1C_n^n=\frac{n!}{0!n!} = 1]]></content>
      <categories>
        <category>数学</category>
        <category>排列与组合</category>
      </categories>
      <tags>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本博客的搭建与维护日志]]></title>
    <url>%2Fblog%2F%E6%9C%AC%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%BB%B4%E6%8A%A4%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[1. 环境的维护1.1. 目标数据不依赖容器，数据都放在宿主机里，容器只用于跑hexo程序，容器可以随时销毁并重新创建。 1.2. 手段宿主机的根目录为/home/kduser/hexo/，容器创建命令仅映射了容器中hexo的source目录，之所以不映射整个hexo目录是因为那样会有问题，原因不明。所以在搭建环境时将除了source外其余的部分（配置文件，样式，服务端.ejs文件等）拷贝到了宿主机，以后仅修改宿主机的这些文件，并通过执行update.sh将这些文件更新到容器里并删除编译生成的public目录。 2. 维护日志2.1. 20180727 初始搭建 下载docker镜像并运行，容器起名为 hexo，指定宿主机与容器的文件映射和端口映射；PS：镜像和容器的关系就好比类与对象的关系 1sudo docker run --name hexo -it -p 80:80 -v /home/kduser/hexo/source:/usr/share/nginx/html/source simplyintricate/hexo 初始化，生成网站的一些静态文件；此处创建的文章《New Post》并不重要，仅是为了通过此命令生成初始的静态文件，这个文章后续删除掉即可 1sudo docker exec -it hexo hexo new "New Post" 该命令具有重新刷新的作用，即根据文章.md文件生成html文件 1sudo docker exec -it hexo hexo generate 将容器除source目录以外的其余部分拷贝到宿主机 123456789101112host="hexo:/usr/share/nginx/html"dest="/home/kduser/hexo"docker cp $&#123;host&#125;/50x.html $&#123;dest&#125;/docker cp $&#123;host&#125;/db.json $&#123;dest&#125;/docker cp $&#123;host&#125;/index.html $&#123;dest&#125;/docker cp $&#123;host&#125;/node_modules $&#123;dest&#125;/docker cp $&#123;host&#125;/package.json $&#123;dest&#125;/docker cp $&#123;host&#125;/public $&#123;dest&#125;/docker cp $&#123;host&#125;/scaffolds $&#123;dest&#125;/docker cp $&#123;host&#125;/themes $&#123;dest&#125;/docker cp $&#123;host&#125;/_config.yml $&#123;dest&#125;/ 2.2. 20180801 更换Next样式 从网上下载样式，解压到themes目录，并更名为next 修改_config.yml，增加配置：theme: next 2.3. 20180810 修改源码修改node_modules\hexo\lib\plugins\generator\page.js，增加以下代码，使得prototype目录下的内容不被hexo处理，原封不动地拷贝到public运行时目录。prototype目录用于放置产品原型html1234567891011var path = page.path;var notRender = ["prototype"]; // 设置不被 render 的目录var dir = path.substring(0, path.indexOf('/'));if (!layout || layout === 'false' || layout === 'off' || (notRender.indexOf(dir) &gt; -1)) &#123; return &#123; path: path, data: page.content &#125;;&#125; 2.4. 20180815 关闭动画效果修改/themes/next/_config.yml，将motion的enable设置为false 2.5. 20180818 修改源码修改node_modules\hexo\lib\plugins\generator\page.js，将20180810的修改内容改为如下：12345678var notRender = []; // 设置不被 render 的目录if(self.config.no_render)&#123; notRender = self.config.no_render.split(",");&#125;var dir = path.substring(0, path.indexOf('/'));if (!layout || layout === 'false' || layout === 'off' || (notRender.indexOf(dir) &gt; -1)) &#123; 然后修改全局的_config_yml，增加：12# 不被渲染的文件或文件夹，用,分隔no_render: prototype 本来想使用hexo-processor-copyassets插件，可惜没效果。 2.6. 20180823 修改npm源，安装hexo-footnotes插件，支持注脚，重新制作镜像修改npm源的原因是内网无法发送https请求，所以用了一个非https的源。123npm config set registry http://registry.npmjs.orgnpm config list #查看更新后的config设置npm install hexo-footnotes --save # 安装插件 尝试安装以下两个插件： hexo-heading-index，标题自动加序号 hexo-generator-searchdb，文章搜索 在外网尝试安装后，执行hexo g会报错，于是上网搜索解决方案，执行以下命令后，问题解决。123sudo npm cache clean -fsudo npm install -g nsudo n stable 但是内网执行n stable会失败，估计又是网络问题。于是尝试将外网的容器迁移到内网来，在外网机器执行命令，将容器打成.tar压缩包：1docker export -o hexo-export.tar hexo 将压缩包拷到内网后，执行命令，将压缩包转化成镜像。1docker import ./hexo-export.tar zhaoyi/hexo-export 完后，执行命令生成容器1sudo docker run --name hexo -it -p 80:80 -p 4000:4000 -v /Users/zhaoyi/Documents/GitHub/hexo/source:/usr/share/nginx/html/source zhaoyi/hexo-export /bin/bash 这里出现了和以前不一样的地方，执行上述命令后会自动进入容器，但只进入根目录，而不是像之前那样能直接进入/usr/share/nginx/html目录。上网查了下资料，可以用以下命令查看之前镜像的一些信息，但只了解到这里而已。1docker inspect simplyintricate/hexo:latest 执行以下命令启动服务，这时不能按ctrl+c退出服务，只能将终端关闭重来1hexo generate &amp;&amp; nginx -g "daemon off;" 内容变更后重新生成网站，要指定-cwd1hexo --cwd /usr/share/nginx/html g 由于有了上述两个插件，所以修改/themes/next/_config.yml，关闭右侧大纲视图的序号输出，并打开本地搜索功能12345678# Table Of Contents in the Sidebartoc: enable: true # Automatically add list number to toc. number: falselocal_search: enable: true 修改/_config.yml，增加内容1234567# 标题加序号heading_index: enable: true index_styles: "&#123;1&#125; &#123;1&#125; &#123;1&#125; &#123;1&#125; &#123;1&#125; &#123;1&#125;" connector: "." global_prefix: "" global_suffix: ". " 2.7. 20180824 超链接样式修改成蓝色在主题配置文件themes/next/_config.yml，新增配置项：123456custom_css: # the style of post body link post_body_a: enable: true normal_color: "#0593d3" hover_color: "#0477ab" next主题提供了用户自定义样式的扩展功能，我们只需要在themes/next/source/css/_custom/custom.styl里添加样式就可以新增或覆盖原来的样式。1234567891011// custom.stylif hexo-config("custom_css.post_body_a.enable") .post-body a&#123; color: convert(hexo-config("custom_css.post_body_a.normal_color")); border-bottom: none; &amp;:hover &#123; color: convert(hexo-config("custom_css.post_body_a.hover_color")); text-decoration: underline; &#125; &#125; 2.8. 20180825 生成tags和categories页按照这里的说明操作即可。按tags为例说明，categories的步骤完全一样： STEP1hexo new page tags STEP2打开 /source/tags/index.md，增加type12345---title: 标签date: 2016-06-08 16:19:38type: "tags"--- STEP3打开 /themes/next/_config.yml，找到menu，打开tags的注释，可能是这样1234567menu: home: / categories: /categories #about: /about archives: /archives tags: /tags #commonweal: /404.html 2.9. 20180826 修改hexo的渲染引擎，以便更好的支持latexhexo在渲染含有下标，大括号的公式时会存在问题，因此参考这篇文章的介绍做了些修改： 替换渲染引擎（先卸载掉旧的，再安装新的）12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save 然后修改node_modules\kramed\lib\rules\inline.js，把第11行的escape变量的值做相应的修改，取消对\,{,}的转义(escape)：12// escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/, escape: /^\\([`*\[\]()#$+\-.!_&gt;])/ 再把第20行的em变量也要做相应的修改。12// em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/ 修改themes/next/_config.yml，将math.per_page属性设为true，以后在需要支持公式的文章中应加上mathjax: true配置。 配置一键发布github按照官方文档配置好后，执行deploy命令，提示需要配置git：12git config --global user.email "you@example.com"git config --global user.name "Your Name" 配置完毕后，由于我的根目录是/blog，所以还要修改/_config.yml的root属性，否则大量文件找不到。完成后，执行hexo g -d，中途会提示输入github的用户名和密码，输入后即可完成发布。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>备忘</tag>
      </tags>
  </entry>
</search>
