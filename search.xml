<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[从单打独斗说起]]></title>
    <url>%2Fblog%2F%E4%BB%8E%E5%8D%95%E6%89%93%E7%8B%AC%E6%96%97%E8%AF%B4%E8%B5%B7%2F</url>
    <content type="text"><![CDATA[我的程序员生涯从大学开始。从使用C语言写出人生第一个HelloWorld程序，到用Java编写出一个图形界面，都是通过个人单打独斗完成的。 参加工作后，虽然存在和同事的沟通与合作，但我的思想在很长时间内一直都处于单打独斗的层面： 激情澎湃时，为了代码看起来酷炫，不考虑易读性 或者身心疲劳时，只管快快完成任务，代码胡乱写，疏忽质量，能跑就行 为了追求完美，对资源限制视而不见 讨厌开会，认为开会大大减少了编写代码的时间 讨厌工作量评估，认为工作量很难准确估计，估了也白估 讨厌项目评分，认为那个制度充满漏洞，得出的分数都是片面的 …… 现在我不这么想了，我不知道是什么因素导致了自己思想的转变。思想转变后，我到图书馆借回一本邹欣著作的《构建之法》从头到尾看了一遍，自觉里头有很多内容点值得再读一遍，应该把它们系统地组织一下，内化到自己的知识库中。不过在此之前，我想先从另一个角度——一个比较偏门的角度，聊聊软件工程的价值。 这又需要提到另一本书，叫《人类简史》。这本书我已经看完一遍了，现正在利用每天搭班车上下班的时间进行第二遍重读，书里面有一个观点大概是这样的： 在距今几十万年以前，人类和地球上的其它动物没有什么不同，而且仅处于食物链的中间层次，面对像狮子那样的大型食肉猛兽时，只有远远躲开，才能避免被吃掉。当时人类也存在很多物种，例如有尼安德特人、直立人、还有今日世上仅存的智人等。一个智人，面对狮子时若不躲避则必死无疑，一个黑猩猩能轻易地将一个智人撕碎，一个智人若和一个尼安德特人直面冲突，估计也只有被对方揍扁的份。那么，智人这个物种是如何成为万物之灵的呢？过程大概是这样的： 可能是从某个偶然的基因突变改变智人大脑的神经连结方式开始，智人获得了一项独特的能力——想象。一般的动物顶多只会和同类说：“小心！河边有只狮子。”而智人则能说：“狮子是部落的守护神。” 一个黑猩猩族群内部的个体互相之间可以很和谐，但不同族群之间不可能会相处融洽，一旦相遇只会大打出手。族群的个体数量顶多只能达到50只，超出这个数量则族群内部就容易产生动乱，导致最后分裂。 而智人则可以通过想象出“神”、“钱”这样的东西，使得部落内的成员数量可以突破50这个数字，且不同部落之间可以互相贸易；通过想象出“公司”、“城市”、“国家”、“法律”这样的概念，使得成百上千、甚至成百万上亿的陌生人之间可以维持相对和谐，产生信任与合作。 一个智人面对一个尼安德特人不占有任何优势，而当100个智人面对100个尼安德特人时，后者绝无任何胜算。拥有共同认可的想象，凭借大量个体之间的充分合作，智人从东非大陆开始扩张，一路所向披靡，灭掉了其他的人类物种，跨洋过海，占领全球，站上了食物链顶端。 从上述观点中可以看到，人类之所以能站上顶峰，并非因为个体如何聪明、单打独斗也足以战胜其它的物种个体，而是因为人类的合作能力是所有物种中最强大的。而人类之所以拥有最强大的合作能力，靠的就是“共同认可的想象”，也就是神灵、钱、国家、法律这样的东西，也可以认为是规范、指标一类的东西。 回到软件工程这个话题，如果只是一个小团队，由几个到十几个人组成，互相之间只靠口头沟通就可以达成任务分派、资源协调、成果验收这样的事情，不需要有任何成体系的规范、指标，所以我当时看到自己的团队在玩敏捷，每天早上都在白板前开立会的时候，心里是很不屑的；白板上贴满了写着任务的便签纸，我还心疼这实在太浪费纸张了；对工作量评估更是感到无聊，由于当时平台（应该称作框架）还不成熟，一个按常规思路估计3人天的任务，一旦遇到了问题，总免不了要和框架的开发人员沟通，那可比和自己团队内部的同事沟通困难多了，几个来回下来，用了几周才完成任务；最可恶的是项目任务和Bug走流程，我们使用的是一个很古老的研发管理平台，用VB开发的，操作起来相当繁琐，叫人热情丧失殆尽，而且没人维护这个系统，改进这些摆明的问题。 然而，“和框架的开发人员沟通更困难”这个现象也反映了一些问题。更进一步，如果面对的是几十上百人的团队，光靠口头沟通是绝对行不通的，得靠一些明确规定、人人都清楚且认可的规范、指标。一个几十上百人的团队，一般由N个“几个或十几个人的小团队”组成。小团队相互距离近，可自由管理；而大团队的领导不能随时了解小团队的内部细节，只能靠规范、指标和小团队沟通；大团队之外还有更大的团队，客户或合作伙伴，这些团体之间的沟通，更要依靠严格明确的标准。 规范明确、指标合理，管理就能有条不紊，反之则混乱不堪。 因此，不能因为执行这些标准会遇到各种各样的麻烦（例如遭遇上面提到的不成熟的框架、破烂不堪的研发管理平台），就放弃标准，得过且过；而要以执行标准，输出必要的数据（例如工作量评估、项目任务和Bug统计）为首要目标，然后不断改进方法，克服其中的苦难。我认为软件工程的目标就是不断寻找更好的规范、指标，以便更高效率地聚合更多人的力量，开发出更优秀的软件。 如果只顾单打独斗，那我的舞台就只能局限于小团队；如果我要管理更大的团队，或者能够正确认识、分析更大的团队，以至于整个行业的状况，我应该学习一些软件工程的知识。]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python常用代码]]></title>
    <url>%2Fblog%2Fpython%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[1. 前言Python是一门灵活的编程语言，它非常适合于编写小工具之类的程序。而由于在日常工作中，我使用的编程语言是Java，对于python的很多语法特性我不熟悉，用它编码时常常遇到各种小问题，虽然这些小问题大部分都可以通过百度和Google很快解决，但解决大量的小问题所耗费的时间累加起来也不小。为了更好地发挥该语言“灵活”的价值，我将个人日常遇到的典型用法编写到该文中，只要大概记得问题的关键字，以后遇到同样的问题时就可以通过 COMMAND(or CTRL) + F 的方式快速获取相关代码样例。 2. 字符串2.1. 使用格式模板构造字符串1'&#123;"word":"%s","sentence":"%s %s %s"&#125;' % (v.get("keyword"),v.get("vt"),v.get("sound"),v.get("desc")) 2.2. 将字符串拆成3份12'111111111aa222222222aa333333333aa'.partition('aa')# 输出 ('111111111', 'aa', '222222222aa333333333aa') 2.3. 查找子串123456789101112131415&gt;&gt;&gt; '0123aa6aa9'.find('aa')4&gt;&gt;&gt; '0123aa6aa9'.find('bb')-1&gt;&gt;&gt; '0123aa6aa9'.index('aa')4&gt;&gt;&gt; '0123aa6aa9'.index('bb')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: substring not found&gt;&gt;&gt; '0123aa6aa9'.find('aa',5)7&gt;&gt;&gt; '0123aa6aa9'.find('aa',-1)-1&gt;&gt;&gt; 2.4. 截取子串1234567&gt;&gt;&gt; '0123456789'[3:6]'345'&gt;&gt;&gt; '0123456789'[3:]'3456789'&gt;&gt;&gt; '0123456789'[:6]'012345'&gt;&gt;&gt; 2.5. 替换123456&gt;&gt;&gt; '111aa111'.replace('aa','bb')'111bb111'&gt;&gt;&gt; import re&gt;&gt;&gt; re.compile(r"&lt;/?b&gt;").sub("","&lt;b&gt;foo&lt;/b&gt;")'foo'&gt;&gt;&gt; 3. 列表、集合、数组3.1. 二维打散成一维1234&gt;&gt;&gt; import operator&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; reduce(operator.add, [[1,2,3],[4,5],[6,7,8]])[1, 2, 3, 4, 5, 6, 7, 8] 3.2. 转换映射（map操作）123456&gt;&gt;&gt; mm = map(lambda v: v+1, [1,2,3])&gt;&gt;&gt; mm&lt;map object at 0x000000000244C390&gt;&gt;&gt;&gt; list(mm)[2, 3, 4]&gt;&gt;&gt; 4. 字典5. 正则5.1. 捕获123sound = re.compile(r'&lt;em class="additional spell phonetic"&gt;(.+?)&lt;/em&gt;').findall(html) if len(sound) &gt; 0: sound = sound[0] 6. 命令行参数12345import argparseparser = argparse.ArgumentParser()parser.add_argument("file", help="the full path of the file which gonna be interpreted as input")args = parser.parse_args()fileNameInput = args.file 7. 文件操作123456789# 读取fileinput = open(fileNameInput, "rt", encoding='utf-8')words = fileinput.read().split("\n")fileinput.close()# 写入fileOutput = open(outputName, "w", encoding='utf-8')fileOutput.write(output)fileOutput.close() 8. 抓取网页1234import urllib.requestpage = urllib.request.urlopen(url)html = page.read()html.decode('utf-8') # 返回网页文本（字符串）]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多级索引]]></title>
    <url>%2Fblog%2F%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[1. 多级索引对于占有$b_i$个块的索引文件，二分查找大约需要 $\log _2 b_i$ 次块访问，多级索引可以减少块访问次数。 将索引文件作为多级索引的第一级，然后，对第一级建立主索引，该主索引作为多级索引的第二级，索引项的数目等于第一级的块数。因为第二级是主索引，所以可以使用块锚。索引文件的块因子 $(bfr_i)$ 又称作多级索引的扇出$(fo)$。若索引文件有$r_1$个项，则第二级则有 $r_2=\lceil (r_1/fo) \rceil$ 个项。 对第二级可重复这一过程，得到第三级，第三级拥有$r_3=\lceil (r_2/fo) \rceil$个项。 只有当第一级所需要的存储空间超过一个块时，才需要第二级。类似地，只有当第二级所需要的存储空间超过一个块时，才需要第三级。重复这个过程直到第t级索引所需要的存储空间在一个块以内，该磁盘块称为顶级索引，其中 $t=\lceil \log _{fo} (r1) \rceil$ 。 以上多级索引模式使用于任何索引类型，但要求第一级索引对K(i)的取值唯一，并且项定长。 1.1. 多级索引如何减少块访问回顾索引基础中的例子3，如果把其中的辅助稠密索引换成多级索引，首先已知 $fo=bfr_i=68$，第一级的块数 $b_1=442$，则 $b_2=\lceil 442/68 \rceil=7$，$b_3=\lceil 7/68 \rceil=1$，因此t=3。通过搜索多级索引访问记录，需要在每一级上进行一次块访问，另外还需要访问一次数据块，因此总共需要 3+1=4 次块访问，而例子3的单级索引需要 10 次块访问。 2. 搜索树p阶搜索树的每个节点可表示为 &lt; $ P_1,K_1,P_2,K_2,…,P_{q-1},K_{q-1},P_q $ &gt;，其中 $q \leqslant p$ 。每个 $P_i$是指向一个子节点（或NULL）的指针，每个 $K_i$是一个搜索值，它来自值的某个有序集合。 搜索树必须满足两个约束条件： 在每个节点中， $K_1 &lt; K_2 &lt; … &lt; K_{q-1}$ 对于 $P_i$ 指向的子树中的所有值X，有 \begin{cases} K_{i-1}]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>数据库理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对数的换底公式]]></title>
    <url>%2Fblog%2F%E5%AF%B9%E6%95%B0%E7%9A%84%E6%8D%A2%E5%BA%95%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[今天当我想用Windows的计算器计算一个对数时，发现计算器只能计算以10为底的对数。于是我条件反射般地打开百度，搜索计算任意底对数的方法，随便点开一个“百度知道”搜素结果，看到的是一个没有排版的回答，然后在一堆字中瞄到了一个除法计算。此时我就把该网页关掉了，虽然我还没掌握解决方案，但我想起了方法：换底公式。 但我只想起这个名称而已，换底公式是怎样的来着？反正现在正在为性能测试灌数据，需要卡住十几分钟，不如趁此尝试推导一下，做做思维体操。现在我的问题就是，$ \log _{a} b $ 可以作何变形，得出一个以10为底的对数表示的式子？ 1. 指数推导法嗯，我对对数不熟悉，对指数更熟悉一点，因此先转换为指数形式，假设： \log _{a} b = r于是有： a^r = b另外也有： e^{\ln a} = a所以： a^r = (e^{\ln a})^r = b = (e^{\ln b})^r上述式子的第二项和第四项，底数都是e，所以指数也相等，所以 \ln a * r = \ln b \\[1em] => r= \frac{\ln b}{\ln a} = \log_{a} b2. 对数推导法换底公式推导出来了，但是，我记得对数的出现时间是早于指数的，所以肯定有纯对数的推导方式。其实对数推导方式是更加简单的，只要对它习惯就好。 首先告诉自己三遍，对于任何的数 a，都可表示成： $ a=e^{\ln a} $。这里用e为底只是举例，实际上用任何数作为底都可以。 然后有 \log _a b = \log _{e^{\ln a}} e^{\ln b} 对数中的指数是可以提取到log符号左边的，例如上式中，$ln a$ 可提到左边作为分母，$ln b$ 可提到左边作为分子，因此： \log _a b = \log _{e^{\ln a}} e^{\ln b} = \frac{\ln b}{\ln a}\log _e e = \frac{\ln b}{\ln a}]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>对数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[索引基础]]></title>
    <url>%2Fblog%2F%E7%B4%A2%E5%BC%95%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[索引是一种存取结构 1. 主索引、聚簇索引和辅助索引根据字段类型是否码字段，可以有如下第一种索引分类方式： 主索引，如果记录文件使用一码字段进行物理排序，基于此字段建立的索引称作主索引 聚簇索引，如果记录文件使用一个非码字段进行物理排序，该字段称作聚簇字段，基于聚簇字段建立的索引称作聚簇索引 辅助索引，是基于记录的非排序字段建立的索引 由于一个文件最多只能有一个物理排序字段，因此一个文件最多只能有一个主索引或一个聚簇索引；而辅助索引则可有多个。 索引由索引项组成，索引项可表示为&lt;k(i), p(i)&gt;。 在主索引中，k(i)是块锚的索引字段值，p(i)是指向块锚的指针。一条索引项的长度小于一条记录的长度，因此一个磁盘块可存储更多的索引项。 磁盘块是磁盘和主存的数据传输单位。一个磁盘块可有多条记录，块因子 bfr (Blocking Factor) 表示一个磁盘块所拥有的记录数。如果取B为一个磁盘块的容量，R为一条记录所占用的容量，则 $ bfr = \lfloor B/R \rfloor $ 。一个磁盘块的第一条记录称为该块的锚记录，或简称块锚。 由于聚簇字段在记录文件中的取值不唯一，同一个聚簇字段值对应的记录可能需要存放在一个或多个块中。常见的做法是为每一个值预留一个整块（或一个连续的块簇），k(i)取聚簇字段值，p(i)取指向对应块的首条记录的指针。 2. 稠密索引和稀疏索引根据索引项数目和记录数目的比例，可有如下第二种索引分类方式： 稠密索引，每条记录都存在对应的一条索引项 稀疏索引，只有部分记录有对应的索引项 关于主索引，由于在记录文件中只有块锚才存在对应的索引项，所以是稀疏索引。 聚簇索引由于每个聚簇字段值对应一个索引项，而同一个聚簇字段值可能会对应多条记录，所以也是稀疏索引。 辅助索引由于使用无序字段作为索引字段，没法使用记录文件的块锚。如果采用候选码作为索引字段，那必须为每个记录建立一个索引项，此时它是稠密索引。而如果采用非码字段作为索引字段，则索引字段取值不唯一，此时根据实现方式的不同，辅助索引可为稠密索引或稀疏索引。 3. 索引如何提升查询效率如果采用对磁盘快访问次数多少作为衡量查询效率的指标，那么考虑以下例子： 例子1：如果一个磁盘块大小B=1024字节，一个文件包含的记录数r=30000个，每条记录的长度R=100字节，记录定长且不跨块。那么存储该文件所需块数b等于多少，二分查找该文件需进行多少次块访问？ 解：块因子 $ bfr=\lfloor B/R \rfloor = 10 $ 个记录/块存储文件所需块数 $ b=\lceil r/bfr \rceil=3000 $ 块块访问次数=$ \lceil \log _{2} b \rceil = 12 $ 次 例子2：在例子1的基础上，如果有建立主索引，其中码字段长9字节（记做K），块指针长6字节（记做P），那么二分查找该索引文件需进行多少次块访问？ 解：一条索引项长度 $ R_i=K+P=15 $ 字节索引块因子（一个磁盘块可以存储的索引项个数）$ bfr_i = \lfloor B/R_i \rfloor = 68$索引项的总数=记录文件的块数=3000个，因此索引文件所需块数$ b_i = \lceil b/bfr_i \rceil = 45$ 块，块访问次数=$ \lceil \log _{2} b_i \rceil + 1 = 6+1 = 7 $ 次，多出的一次是对记录块的访问。 例子3：如果使用无须字段作为查询字段，直接线性查找记录文件平均需要多少次块访问？如果存在辅助索引，则需要多少次块访问？ 解：直接线性查找记录文件平均需要 $ b/2=1500 $ 次块访问辅助索引的索引项数量 $ r_i = r = 30000 $ 个索引文件所需块数 $ b_i = \lceil r_i/bfr_i \rceil = \lceil 30000/68 \rceil = 442 $ 块块访问次数=$ \lceil \log _{2} b_i \rceil + 1 = 9+1 = 10 $ 次 相比主索引的7次块访问，辅助索引稍差一点，但是比起直接线性查找记录文件所需的平均1500次块访问，辅助索引更显著地减少了对磁盘块的访问次数。]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>数据库理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一元n次方程]]></title>
    <url>%2Fblog%2F%E4%B8%80%E5%85%83n%E6%AC%A1%E6%96%B9%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1. 一元二次方程形如 \(f(x) = ax^2 + bx + c\) 称作一元二次方程，即自变量只有一个，自变量的最高次数为2。 1.1. 根的性质想求 \(f(x) = ax^2 + bx + c = 0\) 的根，有一个思路：先将表达式 \(ax^2 + bx + c = 0\) 转成 \((x+A)^2=B\) 的形式，之后即可得 \(x=\pm \sqrt{B}-A\) 。而 \((x+A)^2 = x^2 + 2Ax + A^2\) ，所以先将 \(ax^2 + bx + c = 0\) 转化成这种形式，推导过程如下：消除二次项系数 x^2 + \frac{b}{a}x + \frac{c}{a} = 0即 x^2 + \frac{b}{a}x = -\frac{c}{a}等号两边同时加项，将左边构造成 \(x^2 + 2Ax + A^2\) 的形式 x^2 + \frac{b}{2a}x\cdot 2 + (\frac{b}{2a})^2 = -\frac{c}{a}-(\frac{b}{2a})^2左边变形，右边同分母相加 (x+\frac{b}{2a})^2 = \frac{-4ac+b^2}{4a^2}求得 x=\pm \sqrt{\frac{b^2-4ac}{4a^2}} - \frac{b}{2a} = \frac{-b\pm\sqrt{b^2-4ac}}{2a}1.2. 抛物线性质由以上结果可知，抛物线基于 \(x=-\frac{b}{2a}\) 对称，将该值代入方程，得原点坐标为 \((-\frac{b}{2a},\frac{-b^2+4ac}{4a})\) 。 1.3. 判别式在根表达式中， \(\Delta = b^2-4ac\) 为判别式，可根据判别式的值大于、等于、小于0的情况，判断方程有两个实根，一个实根还是有两个共轭复根。 2. 韦达定理2.1. 定义如果方程 $f(x) = a_0x^n+a_1x^{n-1}+…+a_{n-1}x+a_n=0$ $(a_0\neq 0)$ 的n个根是 $x_1,x_2,…,x_{n-1},x_n$，那么 \begin{cases} x_1+x_2+\cdot\cdot\cdot+x_n = -\frac{a_1}{a_0},\\ x_1x_2+x_1x_3+\cdot\cdot\cdot+x_{n-1}x_n = \frac{a_2}{a_0},\\ \cdot\cdot\cdot\\ x_1x_2x_3 \cdot\cdot\cdot x_{n-1}x_n = (-1)^n\frac{a_n}{a_0}. \end{cases}2.2. 证明据书上1所说，因为 $x_1, x_2, \cdot\cdot\cdot, x_n$ 是 $f(x)=0$ 的根，所以 $f(x)$ 必定含有n个一次因式：$x-x_1, x-x_2, \cdot\cdot\cdot, x-x_{n-1}, x-x_n$ 并且$f(x) = a_0(x-x_1)(x-x_2) \cdot\cdot\cdot (x-x_{n-1})(x-x_n)$2 把上式右端按照$x$降幂展开得 a_0x^n+a_1x^{n-1}+...+a_{n-1}x+a_n =\\ a_0x^n-a_0(x_1+x_2+\cdot\cdot\cdot+x_n)x^{n-1} \\ +a_0(x_1x_2+x_1x_3+\cdot\cdot\cdot+x_{n-1}x_n)x^{n-2}\\ +\cdot\cdot\cdot+(-1)^na_0x_1x_2x_3\cdot\cdot\cdot x_{n-1}x_n这是一个恒等式，根据多项式恒等定理，得\begin{cases}a_1=-a_0(x_1+x_2+\cdot\cdot\cdot+x_n) \\a_2=-a_0(x_1x_2+x_1x_3+\cdot\cdot\cdot+x_{n-1}x_n) \\\cdot\cdot\cdot \\a_n=(-1)^na_0x_1x_2x_3 \cdot\cdot\cdot x_{n-1}x_n\end{cases} 故定理得证 \begin{cases} x_1+x_2+\cdot\cdot\cdot+x_n = -\frac{a_1}{a_0},\\ x_1x_2+x_1x_3+\cdot\cdot\cdot+x_{n-1}x_n = \frac{a_2}{a_0},\\ \cdot\cdot\cdot\\ x_1x_2x_3 \cdot\cdot\cdot x_{n-1}x_n = (-1)^n\frac{a_n}{a_0}. \end{cases}3. 方程变换3.1. 变换后各个根为原方程各个根的k倍定理：方程 $ f(\frac{y}{k}) = 0 $ 的各个根分别等于方程 $ f(x) = 0 $ 各个根的k倍。证明：设 $ a_i(i=1,2,\cdot\cdot\cdot , n) $ 是方程 $ f(x) = 0 $ 的根，则 $ f(a_i) = f(\frac{ka_i}{k}) = 0 $，所以 $ ka_i(i=1,2,\cdot\cdot\cdot , n) $ 是方程 $ f(\frac{y}{k}) = 0 $ 的根，又因为 $ f(\frac{y}{k}) = 0 $ 只有n个根，故 $ f(\frac{y}{k}) = 0 $ 的各根分别等于 $ f(x) = 0 $ 各根的k倍。 3.2. 变换后各个根为原方程各个根相差k$f(y+k)=0$ 的各个根分别等于方程 $ f(x) = 0 $ 的各个根减去k。 3.3. 变换后各个根为原方程各个根的倒数$f(\frac{1}{y})$ 的各个根分别等于方程 $ f(x) = 0 $ 的各个根的倒数。 3.3.1. 倒根方程如果n次方程 $g(x)$ 的各个根分别是n次方程 $f(x) = a_0x^n+a_1x^{n-1}+…+a_{n-1}x+a_n=0$ 各个根的倒数，那么 $g(x) = a_nx^n+a_{n-1}x^{n-1}+…+a_1x+a_0=0$。 1.《初等数学研究》（主编：叶立军）第3.3节 ↩2.这里我能理解当x取这些根值的其中之一时，等式的左右两边都为0，但我还不明白为啥据此能得出 $f(x)$ 一定有这n个因式，且这条等式（不管x取什么值都）成立，这个问题先放着。 ↩]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式定理]]></title>
    <url>%2Fblog%2F%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. 二项式定理$(a+b)^2$可看成$(a+b)(a+b)$，即两个因式(a+b)相乘。观察它的两次乘法分配率的计算过程： (a+b)(a+b)=a\cdot a+ab+ba+b\cdot b可以这样理解：从两个因式中取出两个a相乘，得$a^2$，共有$C_2^2$个1；然后从两个因式中只取一个a（另一个就只能为b了）相乘，得$ab$，共有$C_2^1$个；最后都取b（即都不取a）相乘，共有$C_2^0$个，所以 (a+b)^2 = C_2^2a^2 + C_2^1ab + C_2^0b^2 = a^2+2ab+b^2 同样的思路： (a+b)^3 = C_3^3a^3 + C_3^2a^2b + C_3^1ab^2 + C_3^0b^3 = a^3+3a^2b+3ab^2+b^3还是同样的思路： (a+b)^n = C_n^na^n + C_n^{n-1}a^{n-1}b+C_n^{n-2}a^{n-2}b^2+\cdot\cdot\cdot+C_n^2a^2b^{n-2}+C_n^1ab^{n-1}+C_n^0b^n可以更简单的记为： (a+b)^n = \sum C_n^ma^mb^{n-m}2. 多项式定理考虑$(a+b+c)^3$，将其展开得 a \cdot a \cdot a + a \cdot a \cdot b + a \cdot a \cdot c + \cdot\cdot\cdot可以看出，展开式的每一项的次数都是3，考虑其中一项：$a \cdot a \cdot b$，这一项是两个a和一个b相乘，那么这样的项有多少个呢？有： aab aba baa 3个。所以将展开式合并同类项后，aab项的系数是3. 然后如何用更一般化的方式表示这个3呢？先将aab看成是a1,a2,b这三个不同的元素，那么它们的全排列有 $a1,a2,b$ $a2,a1,b$ $a1,b,a2$ $a2,b,a1$ $b,a1,a2$ $b,a2,a1$ 一共6个。同时 $a1,a2,b$ $a2,a1,b$ 其实是一样的，剩余4个也是同样的道理，将a1和a2看做同一个元素，它们的排列数就是$6/2$个。这一项是一个a取两次，b取1次的3个不尽相异元素的全排列，数量有$\frac{3!}{2! \cdot 1!}$个。 (a_1+a_2+ \cdot\cdot\cdot + a_m)^n = \sum\limits_{n_1+n_2+ \cdot\cdot\cdot + n_m = n} \frac{n!}{\prod\limits_{i=1}^m n_i!}\prod\limits_{i=1}^m a_i^{n_i}1.这里用到了组合的思想，见排列与组合的基本概念。 ↩]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排列与组合的基本概念]]></title>
    <url>%2Fblog%2F%E6%8E%92%E5%88%97%E4%B8%8E%E7%BB%84%E5%90%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[1. 加法原理做一件事情有m类方法，第一类方法中有$n_1$种方法，第二类方法中有$n_2$种方法……第m类方法中有$n_m$种方法，那么完成这件事情一共有$N=n_1+n_2+ … +n_m$种方法。 2. 乘法原理做一件事情有m个步骤，完成第一步有$n_1$种方法，完成第二步有$n_2$种方法……完成第m步有$n_m$种方法，那么完成这件事情一共有$N=n_1n_2 \cdot\cdot\cdot n_m$种方法。 3. 排列3.1. 不无重复排列从n个不同的元素中，不重复地选取m(m&lt;=n)个元素，按照一定的顺序排成一列，称为从n个不同元素中取m个元素的排列。这样取出的所有排列的个数记作$P_n^m$。 从n个元素中取m个元素，第一次取共有n种选法，第二次取共有n-1种选法，第m次取共有n-m+1种选法，根据乘法原理，有 P_n^m=n(n-1)(n-2)\cdot\cdot\cdot(n-m+1) = \frac{n!}{(n-m)!}规定，$0!=1$，$P_n^0=1$ 3.2. 可重复排列数$R_n^m=n^m$ 3.3. 不尽相异元素的全排列定义：在集合$A=\left \{ a_1,a_2,\cdot\cdot\cdot,a_n \right \}$中可重复选取m个元素。 若$a_i$可重复选取$m_i$次，且$\sum\limits_{i=1}^n m_i=m$，则这样的排列数 B_m=\frac{n!}{\prod\limits_{i=1}^n m_i!}4. 组合从n个不同的元素中，不重复地选取m(m&lt;=n)个元素并成一组，称为从n个不同元素中取m个元素的组合，相对排列而言组合不考虑元素的排列顺序，这种组合的个数记作$C_n^m$。 C_n^m=\frac{P_n^m}{P_m^m}=\frac{m!}{(n-m)!\cdot m!}可得推论： C_n^0=\frac{n!}{n!0!} = 1C_n^n=\frac{n!}{0!n!} = 1]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本博客的搭建与维护日志]]></title>
    <url>%2Fblog%2F%E6%9C%AC%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%BB%B4%E6%8A%A4%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[1. 环境的维护1.1. 基本原则数据不依赖容器，数据都放在宿主机里，容器只用于跑hexo程序，容器可以随时销毁并重新创建。 1.2. 本地启动服务以我的mac为例，启动Docker后，打开终端查看容器，启动容器，进入容器，启动hexo服务： 12345678910111213zhaoyi$ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES8616395cc9ba zhaoyi/hexo-export "/bin/bash" 7 months ago Exited (255) 3 months ago 0.0.0.0:80-&gt;80/tcp, 0.0.0.0:4000-&gt;4000/tcp hexozhaoyi$ docker start hexohexozhaoyi$ docker exec -it hexo /bin/bashroot@8616395cc9ba:/# cd /usr/share/nginx/html/root@8616395cc9ba:/usr/share/nginx/html# ls50x.html _config.yml db.json index.html node_modules package-lock.json package.json public scaffolds source themesroot@8616395cc9ba:/usr/share/nginx/html# hexo s(node:39) [DEP0061] DeprecationWarning: fs.SyncWriteStream is deprecated.INFO Start processingINFO Hexo is running at http://0.0.0.0:4000/blog/. Press Ctrl+C to stop. 此时在（宿主机）浏览器输入 http://localhost:4000/blog 即可看到效果。 编辑文章，保存.md文件后，可自动本地发布。 需要发布到Github Page时，可在原来的终端窗口按下 Command+T 打开一个新页签，输入发布命令，发布过程中会提示输入Github的账号和密码：12345678910zhaoyi$ docker exec -it hexo hexo --cwd /usr/share/nginx/html g -d(node:79) [DEP0061] DeprecationWarning: fs.SyncWriteStream is deprecated.INFO Start processing...Username for 'https://github.com': ........Password for 'https://cyclonezhao@github.com': To https://github.com/cyclonezhao/blog 9968c53..73aa262 HEAD -&gt; gh-pagesBranch master set up to track remote branch gh-pages from https://github.com/cyclonezhao/blog.INFO Deploy done: git 2. 维护日志(2018)2.1. 20180727 初始搭建 下载docker镜像并运行，容器起名为 hexo，指定宿主机与容器的文件映射和端口映射；PS：镜像和容器的关系就好比类与对象的关系 1sudo docker run --name hexo -it -p 80:80 -v /home/kduser/hexo/source:/usr/share/nginx/html/source simplyintricate/hexo 初始化，生成网站的一些静态文件；此处创建的文章《New Post》并不重要，仅是为了通过此命令生成初始的静态文件，这个文章后续删除掉即可 1sudo docker exec -it hexo hexo new "New Post" 该命令具有重新刷新的作用，即根据文章.md文件生成html文件 1sudo docker exec -it hexo hexo generate 将容器除source目录以外的其余部分拷贝到宿主机 123456789101112host="hexo:/usr/share/nginx/html"dest="/home/kduser/hexo"docker cp $&#123;host&#125;/50x.html $&#123;dest&#125;/docker cp $&#123;host&#125;/db.json $&#123;dest&#125;/docker cp $&#123;host&#125;/index.html $&#123;dest&#125;/docker cp $&#123;host&#125;/node_modules $&#123;dest&#125;/docker cp $&#123;host&#125;/package.json $&#123;dest&#125;/docker cp $&#123;host&#125;/public $&#123;dest&#125;/docker cp $&#123;host&#125;/scaffolds $&#123;dest&#125;/docker cp $&#123;host&#125;/themes $&#123;dest&#125;/docker cp $&#123;host&#125;/_config.yml $&#123;dest&#125;/ 2.2. 20180801 更换Next样式 从网上下载样式，解压到themes目录，并更名为next 修改_config.yml，增加配置：theme: next 2.3. 20180810 修改源码修改node_modules\hexo\lib\plugins\generator\page.js，增加以下代码，使得prototype目录下的内容不被hexo处理，原封不动地拷贝到public运行时目录。prototype目录用于放置产品原型html1234567891011var path = page.path;var notRender = ["prototype"]; // 设置不被 render 的目录var dir = path.substring(0, path.indexOf('/'));if (!layout || layout === 'false' || layout === 'off' || (notRender.indexOf(dir) &gt; -1)) &#123; return &#123; path: path, data: page.content &#125;;&#125; 2.4. 20180815 关闭动画效果修改/themes/next/_config.yml，将motion的enable设置为false 2.5. 20180818 修改源码修改node_modules\hexo\lib\plugins\generator\page.js，将20180810的修改内容改为如下：12345678var notRender = []; // 设置不被 render 的目录if(self.config.no_render)&#123; notRender = self.config.no_render.split(",");&#125;var dir = path.substring(0, path.indexOf('/'));if (!layout || layout === 'false' || layout === 'off' || (notRender.indexOf(dir) &gt; -1)) &#123; 然后修改全局的_config_yml，增加：12# 不被渲染的文件或文件夹，用,分隔no_render: prototype 本来想使用hexo-processor-copyassets插件，可惜没效果。 2.6. 20180823 修改npm源，安装hexo-footnotes插件，支持注脚，重新制作镜像修改npm源的原因是内网无法发送https请求，所以用了一个非https的源。123npm config set registry http://registry.npmjs.orgnpm config list #查看更新后的config设置npm install hexo-footnotes --save # 安装插件 尝试安装以下两个插件： hexo-heading-index，标题自动加序号 hexo-generator-searchdb，文章搜索 在外网尝试安装后，执行hexo g会报错，于是上网搜索解决方案，执行以下命令后，问题解决。123sudo npm cache clean -fsudo npm install -g nsudo n stable 但是内网执行n stable会失败，估计又是网络问题。于是尝试将外网的容器迁移到内网来，在外网机器执行命令，将容器打成.tar压缩包：1docker export -o hexo-export.tar hexo 将压缩包拷到内网后，执行命令，将压缩包转化成镜像。1docker import ./hexo-export.tar zhaoyi/hexo-export 完后，执行命令生成容器1sudo docker run --name hexo -it -p 80:80 -p 4000:4000 -v /Users/zhaoyi/Documents/GitHub/hexo/source:/usr/share/nginx/html/source zhaoyi/hexo-export /bin/bash 这里出现了和以前不一样的地方，执行上述命令后会自动进入容器，但只进入根目录，而不是像之前那样能直接进入/usr/share/nginx/html目录。上网查了下资料，可以用以下命令查看之前镜像的一些信息，但只了解到这里而已。1docker inspect simplyintricate/hexo:latest 执行以下命令启动服务，这时不能按ctrl+c退出服务，只能将终端关闭重来1hexo generate &amp;&amp; nginx -g "daemon off;" 内容变更后重新生成网站，要指定-cwd1hexo --cwd /usr/share/nginx/html g 由于有了上述两个插件，所以修改/themes/next/_config.yml，关闭右侧大纲视图的序号输出，并打开本地搜索功能12345678# Table Of Contents in the Sidebartoc: enable: true # Automatically add list number to toc. number: falselocal_search: enable: true 修改/_config.yml，增加内容1234567# 标题加序号heading_index: enable: true index_styles: "&#123;1&#125; &#123;1&#125; &#123;1&#125; &#123;1&#125; &#123;1&#125; &#123;1&#125;" connector: "." global_prefix: "" global_suffix: ". " 2.7. 20180824 超链接样式修改成蓝色在主题配置文件themes/next/_config.yml，新增配置项：123456custom_css: # the style of post body link post_body_a: enable: true normal_color: "#0593d3" hover_color: "#0477ab" next主题提供了用户自定义样式的扩展功能，我们只需要在themes/next/source/css/_custom/custom.styl里添加样式就可以新增或覆盖原来的样式。1234567891011// custom.stylif hexo-config("custom_css.post_body_a.enable") .post-body a&#123; color: convert(hexo-config("custom_css.post_body_a.normal_color")); border-bottom: none; &amp;:hover &#123; color: convert(hexo-config("custom_css.post_body_a.hover_color")); text-decoration: underline; &#125; &#125; 2.8. 20180825 生成tags和categories页按照这里的说明操作即可。按tags为例说明，categories的步骤完全一样： STEP1hexo new page tags STEP2打开 /source/tags/index.md，增加type12345---title: 标签date: 2016-06-08 16:19:38type: "tags"--- STEP3打开 /themes/next/_config.yml，找到menu，打开tags的注释，可能是这样1234567menu: home: / categories: /categories #about: /about archives: /archives tags: /tags #commonweal: /404.html 2.9. 20180826 修改hexo的渲染引擎，以便更好的支持latexhexo在渲染含有下标，大括号的公式时会存在问题，因此参考这篇文章的介绍做了些修改： 替换渲染引擎（先卸载掉旧的，再安装新的）12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save 然后修改node_modules\kramed\lib\rules\inline.js，把第11行的escape变量的值做相应的修改，取消对\,{,}的转义(escape)：12// escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/, escape: /^\\([`*\[\]()#$+\-.!_&gt;])/ 再把第20行的em变量也要做相应的修改。12// em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/ 修改themes/next/_config.yml，将math.per_page属性设为true，以后在需要支持公式的文章中应加上mathjax: true配置。 配置一键发布github按照官方文档配置好后，执行deploy命令，提示需要配置git：12git config --global user.email "you@example.com"git config --global user.name "Your Name" 配置完毕后，由于我的根目录是/blog，所以还要修改/_config.yml的root属性，否则大量文件找不到。完成后，执行hexo g -d，中途会提示输入github的用户名和密码，输入后即可完成发布。 2.10. 20180916 支持代码折叠部分改动这里的做法： 1234567891011121314151617181920212223242526272829303132333435363738// 修改themes/next/source/js/src/motion.js，最后面加上以下代码$(document).ready(function()&#123; $(document).on('click', '.hider_title', function()&#123; $('&gt;.fold', this.parentNode.parentNode).slideToggle(); $('&gt;:first', this.parentNode).toggleClass('open'); &#125;); //默认情况下折叠 $("div.fold").css("display","none");&#125;);// 新增 themes/next/scripts/tags.jsconst rEscapeContent = /&lt;escape(?:[^&gt;]*)&gt;([\s\S]*?)&lt;\/escape&gt;/g;const placeholder = '\uFFFD';const rPlaceholder = /(?:&lt;|&amp;lt;)\!--\uFFFD(\d+)--(?:&gt;|&amp;gt;)/g;const cache = [];function escapeContent(str) &#123; return '&lt;!--' + placeholder + (cache.push(str) - 1) + '--&gt;';&#125;hexo.extend.filter.register('before_post_render', function(data) &#123; data.content = data.content.replace(rEscapeContent, function(match, content) &#123; return escapeContent(content); &#125;); return data;&#125;);hexo.extend.filter.register('after_post_render', function(data) &#123; data.content = data.content.replace(rPlaceholder, function() &#123; return cache[arguments[1]]; &#125;); return data;&#125;);// 新增 themes/next/scripts/fold.jsfunction fold (args, content) &#123; var text = args[0]; if(!text) text = ""; return '&lt;div&gt;&lt;div class="fold_hider"&gt;&lt;a class="close hider_title"&gt;' + text + '&lt;/a&gt;&lt;/div&gt;&lt;div class="fold"&gt;\n' + hexo.render.renderSync(&#123;text: content, engine: 'markdown'&#125;) + '\n&lt;/div&gt;&lt;/div&gt;';&#125;hexo.extend.tag.register('fold', fold, &#123;ends: true&#125;); 1234567891011121314151617/*修改themes/next/source/css/_custom/custom.styl，增加内容*/div.fold&#123; display: none;&#125;.hider_title&#123; font-family: "Microsoft Yahei"; cursor: pointer; &amp;:hover&#123; text-decoration: none; &#125;&#125;.close:after&#123; content: "展开代码";&#125;.open:after&#123; content: "收起代码";&#125;]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
</search>
