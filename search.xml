<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[构建之法]]></title>
    <url>%2Fblog%2F%E6%9E%84%E5%BB%BA%E4%B9%8B%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. 软件工程的目标目标是创建“足够好”的软件，而不是完美的软件。 2. 软件开发过程的难题 复杂性 不可见性 易变性 服从性 非连续性 3. 什么是Bug某软件在运行过程中奔溃了，用户期望这个软件不能奔溃。 某软件不支持视频聊天，用户期望这个软件支持视频聊天。但是该软件的开发人员说，这个软件本来就没打算支持视频聊天。这还是一个Bug么？ 4. 个人能力的衡量类比NBA的出场数、命中率、进攻、抢断、盖帽等衡量指标，有没有类似的数据衡量一个软件工程师的个人能力和成绩？ 5. 两人合作5.1. 阶段萌芽阶段 两人刚刚互相认识，彼此并不了解，大家都有礼貌，一般性的交流不少，每个人都想得到对方的接纳，避免冲突和提出容易引起挑战的观点。 磨合阶段 开始跳舞，开始踩脚。 规范阶段 跳舞逐渐和谐、合拍，一些成文或不成文的规则逐步建立起来。 创造阶段 跳舞两人合二为一，为艺术而舞蹈。 解体阶段 散伙，各走各的，回宿舍抱着板凳跳舞，或者另找舞伴。 5.2. 如何影响对方 方式 简介 逻辑/感情 推/拉 注解 断言 就是这样吧，听我的没错！ 感情 推——主动推动同伴做某事 感情很强烈，适用于有充分信任的同伴。语音、语调、肢体语言都能帮助传递强烈的信息 桥梁 能否再给我讲讲你的理由…… 逻辑 拉——吸引对方，建立共识 给双方充分条件互相了解 说服 如果我们这样做，会有以下好处…… 逻辑 推——让对方思考 有条理，建立在逻辑分析的基础上。即使不能全部说服，对方也可能接受部分意见 吸引 你想发财么？加入我们传销队伍吧，几个月后就有上百万的收入…… 感情 拉——描述理想状态，吸引对方加入 可以有效地传递信息，但是要注意信息的准确性。夸大的渲染会降低个人的可信度 思考一个问题：深夜宿舍大楼着火了，大家都赶紧往外跑，但你的室友还在为穿哪一件衣服出去而挑来挑去。这时你会选哪一种方法？挑梁？说服？吸引？还是断言？ 5.3. 反馈的三个层次最外层：行为和后果——你迟到了，我们进不了会场了。中间层：习惯和动机——你怎么又放我鸽子，你总是不重视我，你是故意耍我！最内层：本质和固有属性——你太自私了，你们男人没一个好东西！ 最外层表示行为可以改正，后果可以弥补，对方还有挽回的机会；中间层上升到行为和动机，对方比较难表白和澄清；最内层是深入到核心和本质，对方很难或者无法回应。 6. 需求分析6.1. 步骤6.1.1. 获取和引导需求软件团队需要找到利益相关者，了解和挖掘他们对软件的需求，引导他们表达出对软件的需求。 6.1.2. 分析和定义需求从各个角度将需求量化。例如：有多少用户有这样的需求，他们大致能承受什么样的价位，实现需求大致所需的成本等。 6.1.3. 验证需求通过和利益相关者沟通、报告、演示等方式，验证自己对需求的认知是否正确。 6.1.4. 管理需求在软件的生命周期内，技术在发展，相关政策法规在变化，因此需求也会变化，我们需要不断做相应的调整。 6.2. 需求的类型6.2.1. 功能需求要求产品必须实现某些功能。 6.2.2. 开发过程的需求要求软件的开发流程必须满足某些约束条件。例如必须产生某种类型的文档，必须在某个时间点达到某个状态等。 6.2.3. 非功能性需求这也叫“服务质量需求”(Quality of Service Requirement)，例如性能、高可用、高并发等。 6.2.4. 综合需求例如物流方面的需求，牵涉到软件系统、货物派送系统、送货部门、监控系统等不同实体的功能和执行能力。 6.3. 利益相关者6.3.1. 用户直接使用软件系统的人。 6.3.2. 顾客他们的利益和软件直接相关，但不一定是直接用户。例如，给小孩买学习软件的家长。 6.3.3. 市场分析师他们应代表“典型用户”的需求。 6.3.4. 监管机构在银行、交通、通信等行业中，软件必须符合相关的政策规定。 6.3.5. 软件工程师软件的各种约束和特性会影响他们的工作效率、开发和维护的难度，他们应该参与到软件的需求阶段来。 6.4. 获取用户需求——用户调查在焦点小组的方式上，讨论者容易受到主持人的影响。深入面谈费时费力，效果取决于面谈主持人的能力。调查问卷则存在问题定义可能不明确，修饰词含糊不清（最近、经常等），需要用户花费额外的努力回答问题，问题可能带有引导性倾向等坏处。 各种方法可按如下维度分类：横坐标（从定性到定量），纵坐标（从听其言到观其行） 6.5. 说服别人的套路（NABCD模型）Need，注意在汽车发明之前，马车夫只会告诉福特说他希望他的马跑得更快些。Approach，有什么招数，特别是独特的招数，来解决用户的痛点。Benefit，使用我的产品能给用户带来什么好处？Competitors，考虑【我们的产品】【他们的产品】【用户需求】这三个集合的关系，看清我方优势和劣势分别在哪里。Delivery，如何把我当产品交到用户的手中。 6.6. 功能定位的四象限方法横坐标：杀手功能/外围功能纵坐标：必要需求/辅助需求 对不同类型功能的应对办法： 维持——以最低成本维持此功能 抵消——做到“和竞争对手差不多” 优化——花大力气做到并保持行业最好 差异化——我有人无 不做——我们并不要做所有的功能 | 外围功能 | 杀手功能必要需求 | 建议采取“抵消”的办法，快速地达到“和别人差不多”，对于大家都特别看重的功能，采取“优化”的办法，达到行业最佳 | 建议采取“差异化”的办法，全力以赴投资在这个领域辅助需求 | 建议采取“维持”的办法，以最低代价维持此功能 | （不是用户的刚需，而是辅助功能，但是我们有独特的办法做得更好）建议采取“维持”的办法，或者现在“不做”，等待好的时机。或者让小部分人员做实验。 6.7. 计划和估计分清目标、估计、决心。 7. 测试7.1. 好的单元测试的标准7.1.1. 单元测试要测试API中的每一个方法及参数7.1.2. 单元测试应该由最熟悉代码的人来写如果忙到连单元测试都没时间做，那么你也没有时间写好这个功能。如果没有单元测试，API语义的正确性就不能得到保障，以后会产生歧义。 7.1.3. 单元测试过后，机器状态保持不变7.1.4. 单元测试要快一个测试的运行时间是几秒钟，而不是几分钟。 7.1.5. 重复运行一个单元测试，应该产生一致的结果7.1.6. 单元测试的独立性单元测试的运行/通过/失败不依赖以及不影响别的测试。可以通过人为构造数据保持单元测试的独立性。 7.1.7. 单元测试应该覆盖所有的代码路径7.1.8. 单元测试自动化这样每个人都能随时随地运行单元测试，最好在每日构建之后运行单元测试，这样错误就能及时发现并修改。 7.1.9. 单元测试必须和产品代码一起保存和维护7.2. 回归测试我们可以将“回归”理解为“回归到以前不正常的状态”。工程师们应该在新版本上运行所有之前已通过的测试用例，以验证有没有“退化”情况发生，这个过程就是一个”Regression Test”。]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[零基础学会计]]></title>
    <url>%2Fblog%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%BC%9A%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[1. 认识会计工作1.1. 什么是会计记录这些内容：通过一段时间的经营，收入多少，付出多少成本，资金周转多长时间等等。后续根据这些记录决定下一步是扩大经营规模还是吸引投资，或是改变经营管理方式等。 1.2. 职业资格1.3. 会计基本职能《会计法》中将会计的基本职能明确为进行会计核算和会计监督。 会计核算职能是以货币为主要计量单位，通过确认、记录、计量、报告，对特定主体一定时期的经济活动进行记账、算账、报账，为有关各方面提供会计信息的功能。 会计监督是指会计人员通过会计工作对经济活动的真实性、合理性、合法性进行审查的功能。 1.4. 岗位设置出纳、会计、会计主管是企业必设的岗位。如果企业的规模和业务量较大还会设置更多的岗位，比如材料物资核算、库存商品核算、往来结算、工资核算、成本费用核算、稽核、固定资产核算等。 出纳办理银行的现金收付、银行结算及有关账务，保管库存现金、有价证券、财务印章及有关票据等工作。简单来说，出纳岗位是负责一切与企业货币资金业务相关的岗位。 2. 会计工作的理论基础2.1. 会计工作的前提：四大基本假设会计主体假设，持续经营假设，会计分期假设，货币计量假设 2.2. 会计核算的八项原则可靠性原则，相关性原则，可理解性原则，可比性原则，实质重于形式原则，重要性原则，谨慎性原则，及时性原则 2.3. 会计要素通俗地讲，会计要素实际上就是把经济活动中需要会计处理的各项事务进行分类形成的。由于各会计要素在属性上有其共通性，所以在会计处理上也能够进行类似处理，这样可以方便会计核算中的分类核算。 会计要素分为两类： 反应企业财务状况的会计要素：资产、负债和所有者权益 反应企业经营成果的会计要素：收入、费用和利润 资产是指企业在过去的交易或事项中形成的，由企业拥有或控制的资源，且该资源会给企业带来经济利益。负债是指企业在过去的交易或事项中形成的现时义务，履行该义务预期会导致经济利益流出企业。所有者权益是指所有者在企业资产中享有的经济利益，其金额等于资产减去负债后的余额，表示一个会计主体在一定时期所拥有的或可控制的具有未来经济利益资源的净额。收入是指企业在销售商品、提供劳务及让渡资产使用权等日常活动中形成的经济利益总流入。费用是指企业在销售商品、提供劳务等日常活动中所发生的经济利益的流出。利润是指企业在一定会计期间的经营成果，即企业在销售商品的收入扣除成本价和税金之后的余额。 2.4. 各大会计要素之间的关系2.4.1. 资产=权益资产和权益是一物的两面，是对立统一的关系。有一定的资产，就有一定的权益，反之亦然。 权益并不等同于所有者权益，所有者权益是资产剔除负债后剩下的部分。 2.4.2. 会计等式1：资产=负债+所有者权益它反映了企业资金运动的静态状况，也就是某一时点上的状况。不同时点上的数据不具有可加性，数据是以非连续的统计方式得到，数据自身的大小与统计的时间间隔长短无必然关系。 2.4.3. 会计等式2：收入-费用=利润（或亏损）即“得到的-付出的=赚的（或亏的）”。这个等式从时间上分析是动态的，反映了会计主体在某一时期的经营成果，数据以连续统计的方式得到，不同时间段上的数据具有可加性。 这个等式反映了企业资金运动的状况，所有的资产都是为了赚钱，而资产一旦运用并取得收入时，资产就转化为费用，收入减去费用即为利润，又叫净收益。 净收益又会作为资产用到下一轮的经营中，于是就产生了下面的会计等式3. 2.4.4. 会计等式3（综合式）：资产=负债+所有者权益+收入-费用新的所有者权益=旧的所有者权益+利润=旧的所有者权益+收入-费用新的资产=负债+新的所有者权益=负债+旧的所有者权益+收入-费用 2.4.5. 会计扩张恒等式4：资产+费用=负债+所有者权益+收入将等式3中的利润按等式2展开，再将各类要素按其对应的账户性质进行归类、移项、得到此会计等式4。 2.5. 经济业务的发生对会计等式的影响 资产和权益同时增加 资产和权益同时减少 资产之间有增有减 权益之间有增有减 为何不包含负债的增减？ 2.6. 会计科目会计科目是按照经济业务的内容和经济管理的要求，对会计对象的具体内容进行分类核算的项目。 会计科目按经济内容可分为五大类： 资产类 负债类 共同类（不清楚是什么类型，3开头） 所有者权益类 成本类 损益类 按提供信息的详细程度可分为总账科目和明细科目。 2.7. 设置账户3. 凭证的使用和管理凭证的种类：原始凭证，记账凭证。 一般情况下，原始凭证是不能作为登记账簿的直接依据的，需要将来自不同单位、种类繁多、数量庞大、格式大小不一的原始凭证加以归类、整理，填制具有统一格式的记账凭证，然后才能根据记账凭证来进行账簿的记录。 记账凭证的种类： 收款凭证付款凭证转账凭证记账凭证（即通用记账凭证，不再区分收款、付款和转账，只以一种格式记录全部经济业务） 4. 账簿的使用和管理账簿由具有一定格式、相互联结的账页所组成，用于全面、连续、系统、科学地记录和反映各项经济业务的簿籍。 账簿的作用： 存储会计信息 汇总会计信息 检查、校正会计信息 编表、输出会计信息 4.1. 对账4.2. 结账5. 具体业务的账务核算账务处理程序也称会计核算组织程序，是指对会计数据的记录、归类、汇总、申报的步骤和方法，即从原始凭证的整理、汇总，记账凭证的填制、汇总，日记账、明细账的登记到会计报表的编制的步骤和方法。 账务处理程序的基本模式可以概括为：原始凭证-记账凭证-会计账簿-会计报表。 5.1. 银行取款和存款5.2. 收入的账务处理5.3. 进货的账务处理5.4. 费用的账务处理5.5. 往来账款核算5.6. 固定资产核算5.7. 工资核算6. 财产清查财产清查是对各项资产、物资进行实地盘存和核对，查明财产物资、货币资金和结算款项的实有数额，确定其账面结存数额和实际结存数额是否一致，以保证账实相符的一种会计专门方法。 6.1. 财产清查的作用 确定各项财产物资、债权债务的实有数，查明账存额和实存额之间的差异，以及产生差异的原因和责任，以便及时调整账面记录，使账存额和实有额一致，保证会计核算资料的真实性和可靠性。 查明各项财产物资的储备和利用情况，以便采取措施，充分挖掘财产物资的潜力，促进财产物资的有效使用。 查明各项财产物资有无挪用、贪污、盗窃，以及损毁、变质和浪费等情况，以便及时采取措施，加强管理，保证各项财产物资的安全性和完整性。 检查会计主体对财经纪律的遵守情况，查明各种往来结算款项的结算是否正常，及早发现长期拖欠的债权、债务，避免坏账损失的发生，并自觉遵守结算纪律和制度。 查明财产物资的验收、保管、调拨、报废，以及现金出纳、账款结算等手续制度的贯彻和落实情况，发现问题并及时采取措施，建立、健全有关规章制度，提高管理水平。 6.2. 财产清查的种类 按清查对象和范围：全面清查，局部清查 按清查时间：定期清查，不定期清查 6.3. 财产物资的盘存制度指的是日常会计核算中采用什么方法确定各项财产物资的盘存数。 永续盘存制 实地盘存制 6.4. 财产清查结果的处理6.4.1. 主要有以下方面： 查明盘盈盘亏的原因并按规定进行处理 总结经验教训，建立和健全财产管理制度 及时处理积压物资 进行盘盈、盘亏的账务处理 6.4.2. 实例7. 月底账务处理7.1. 月末都要处理什么事情 先对本月的所有凭证进行全面审核、仔细核对，以减少差错 进行账实核对 对相关税金进行计算与核对 查看所有明细科目余额，对有异常方向余额进行调整 进行月末结账结转凭证的编制 对账簿记录进行月结处理 7.2. 计提与摊销月底的计提与摊销事项处理的是与平常业务发生关联不大，只是根据会计事项规定应处理的事宜。新会计准则取消了“预提费用”和“待摊费用”两个科目，因此除税金的计算提取外，需要计提摊销的业务基本就是提取折旧和利息事项。 7.3. 结转成本7.4. 税金计算 增值税 企业所得税 消费税 附加税 印花税 代扣代缴个人所得税 7.5. 结转利润 各项收入的结转 期间费用的结转 成本支出的结转 税金的结转 8. 财务报表的编制财务报告是反映企业财务状况和经营成果的书面文件，包括资产负债表、利润表、现金流量表、所有者权益变动表、财务报表附注和财务情况说明书。它是企业根据日常会计核算资料归集、加工和汇总后形成的，是企业会计核算的最终成果，即企业每一期间的成绩单。 8.1. 财务报表的重要作用有以下几点： 财务报表是与企业有经济利害关系的外部单位和个人了解企业的财务状况和经营成果，并据以做出决策的重要依据 财务报表是国家经济管理部门进行宏观调控和管理的信息源 财务报表提供的经济信息是企业内部加强和改善经营管理的重要依据 8.2. 资产负债表是指反映企业在某一特定日期的财务状况的报表，满足“资产=负债+所有者权益”平衡公式。 8.3. 利润表又称损益表，是指反映企业在一定会计期间的经营成果的报表。 利润表是用来核算企业一定时期利润（亏损）实际情况的，而利润（或亏损）的实际情况又是通过收入与费用的对比体现出来的。所以，会计等式“收入-费用=利润”即为利润表编制的理论依据。利润可进一步细分为“利润总额=销售利润+投资净收益+营业外收支净额”，这样能区分企业通过不同途径取得的收入和获利情况。 8.4. 现金流量表是反映企业在一定会计期间内，现金和现金等价物流入和流出的报表。 它的编制基础是收付实现制，即只记录当期现金的收支情况，而不考虑这些现金流入流出是否归属于当期损益，是否归企业所有。其理论依据为：当期现金净增加额=经营现金净流量+投资现金净流量+筹资现金净流量。 8.5. 所有者权益变动表反映企业在一定会计期间内，所有者权益构成及增减变化情况的报表。 8.6. 财务报表附注是对财务报表本身无法或难以充分表达的内容和项目所做的补充说明和详细解释。]]></content>
      <categories>
        <category>经济学</category>
      </categories>
      <tags>
        <tag>会计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python常用代码]]></title>
    <url>%2Fblog%2Fpython%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[1. 前言Python是一门灵活的编程语言，它非常适合于编写小工具之类的程序。而由于在日常工作中，我使用的编程语言是Java，对于python的很多语法特性我不熟悉，用它编码时常常遇到各种小问题，虽然这些小问题大部分都可以通过百度和Google很快解决，但解决大量的小问题所耗费的时间累加起来也不小。为了更好地发挥该语言“灵活”的价值，我将个人日常遇到的典型用法编写到该文中，只要大概记得问题的关键字，以后遇到同样的问题时就可以通过 COMMAND(or CTRL) + F 的方式快速获取相关代码样例。 2. 字符串2.1. 使用格式模板构造字符串1'&#123;"word":"%s","sentence":"%s %s %s"&#125;' % (v.get("keyword"),v.get("vt"),v.get("sound"),v.get("desc")) 2.2. 将字符串拆成3份12'111111111aa222222222aa333333333aa'.partition('aa')# 输出 ('111111111', 'aa', '222222222aa333333333aa') 2.3. 查找子串123456789101112131415&gt;&gt;&gt; '0123aa6aa9'.find('aa')4&gt;&gt;&gt; '0123aa6aa9'.find('bb')-1&gt;&gt;&gt; '0123aa6aa9'.index('aa')4&gt;&gt;&gt; '0123aa6aa9'.index('bb')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: substring not found&gt;&gt;&gt; '0123aa6aa9'.find('aa',5)7&gt;&gt;&gt; '0123aa6aa9'.find('aa',-1)-1&gt;&gt;&gt; 2.4. 截取子串1234567&gt;&gt;&gt; '0123456789'[3:6]'345'&gt;&gt;&gt; '0123456789'[3:]'3456789'&gt;&gt;&gt; '0123456789'[:6]'012345'&gt;&gt;&gt; 2.5. 替换123456&gt;&gt;&gt; '111aa111'.replace('aa','bb')'111bb111'&gt;&gt;&gt; import re&gt;&gt;&gt; re.compile(r"&lt;/?b&gt;").sub("","&lt;b&gt;foo&lt;/b&gt;")'foo'&gt;&gt;&gt; 3. 列表、集合、数组3.1. 二维打散成一维1234&gt;&gt;&gt; import operator&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; reduce(operator.add, [[1,2,3],[4,5],[6,7,8]])[1, 2, 3, 4, 5, 6, 7, 8] 3.2. 转换映射（map操作）123456&gt;&gt;&gt; mm = map(lambda v: v+1, [1,2,3])&gt;&gt;&gt; mm&lt;map object at 0x000000000244C390&gt;&gt;&gt;&gt; list(mm)[2, 3, 4]&gt;&gt;&gt; 4. 字典5. 正则5.1. 捕获123sound = re.compile(r'&lt;em class="additional spell phonetic"&gt;(.+?)&lt;/em&gt;').findall(html) if len(sound) &gt; 0: sound = sound[0] 6. 命令行参数12345import argparseparser = argparse.ArgumentParser()parser.add_argument("file", help="the full path of the file which gonna be interpreted as input")args = parser.parse_args()fileNameInput = args.file 7. 文件操作123456789# 读取fileinput = open(fileNameInput, "rt", encoding='utf-8')words = fileinput.read().split("\n")fileinput.close()# 写入fileOutput = open(outputName, "w", encoding='utf-8')fileOutput.write(output)fileOutput.close() 8. 抓取网页1234import urllib.requestpage = urllib.request.urlopen(url)html = page.read()html.decode('utf-8') # 返回网页文本（字符串）]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多级索引]]></title>
    <url>%2Fblog%2F%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[1. 多级索引对于占有$b_i$个块的索引文件，二分查找大约需要 $\log _2 b_i$ 次块访问，多级索引可以减少块访问次数。 将索引文件作为多级索引的第一级，然后，对第一级建立主索引，该主索引作为多级索引的第二级，索引项的数目等于第一级的块数。因为第二级是主索引，所以可以使用块锚。索引文件的块因子 $(bfr_i)$ 又称作多级索引的扇出$(fo)$。若索引文件有$r_1$个项，则第二级则有 $r_2=\lceil (r_1/fo) \rceil$ 个项。 对第二级可重复这一过程，得到第三级，第三级拥有$r_3=\lceil (r_2/fo) \rceil$个项。 只有当第一级所需要的存储空间超过一个块时，才需要第二级。类似地，只有当第二级所需要的存储空间超过一个块时，才需要第三级。重复这个过程直到第t级索引所需要的存储空间在一个块以内，该磁盘块称为顶级索引，其中 $t=\lceil \log _{fo} (r1) \rceil$ 。 以上多级索引模式使用于任何索引类型，但要求第一级索引对K(i)的取值唯一，并且项定长。 1.1. 多级索引如何减少块访问回顾索引基础中的例子3，如果把其中的辅助稠密索引换成多级索引，首先已知 $fo=bfr_i=68$，第一级的块数 $b_1=442$，则 $b_2=\lceil 442/68 \rceil=7$，$b_3=\lceil 7/68 \rceil=1$，因此t=3。通过搜索多级索引访问记录，需要在每一级上进行一次块访问，另外还需要访问一次数据块，因此总共需要 3+1=4 次块访问，而例子3的单级索引需要 10 次块访问。 2. 搜索树p阶搜索树的每个节点可表示为 &lt; $ P_1,K_1,P_2,K_2,…,P_{q-1},K_{q-1},P_q $ &gt;，其中 $q \leqslant p$ 。每个 $P_i$是指向一个子节点（或NULL）的指针，每个 $K_i$是一个搜索值，它来自值的某个有序集合。 搜索树必须满足两个约束条件： 在每个节点中， $K_1 &lt; K_2 &lt; … &lt; K_{q-1}$ 对于 $P_i$ 指向的子树中的所有值X，有 \begin{cases} K_{i-1}]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>数据库理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对数的换底公式]]></title>
    <url>%2Fblog%2F%E5%AF%B9%E6%95%B0%E7%9A%84%E6%8D%A2%E5%BA%95%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[今天当我想用Windows的计算器计算一个对数时，发现计算器只能计算以10为底的对数。于是我条件反射般地打开百度，搜索计算任意底对数的方法，随便点开一个“百度知道”搜素结果，看到的是一个没有排版的回答，然后在一堆字中瞄到了一个除法计算。此时我就把该网页关掉了，虽然我还没掌握解决方案，但我想起了方法：换底公式。 但我只想起这个名称而已，换底公式是怎样的来着？反正现在正在为性能测试灌数据，需要卡住十几分钟，不如趁此尝试推导一下，做做思维体操。现在我的问题就是，$ \log _{a} b $ 可以作何变形，得出一个以10为底的对数表示的式子？ 1. 指数推导法嗯，我对对数不熟悉，对指数更熟悉一点，因此先转换为指数形式，假设： \log _{a} b = r于是有： a^r = b另外也有： e^{\ln a} = a所以： a^r = (e^{\ln a})^r = b = (e^{\ln b})^r上述式子的第二项和第四项，底数都是e，所以指数也相等，所以 \ln a * r = \ln b \\[1em] => r= \frac{\ln b}{\ln a} = \log_{a} b2. 对数推导法换底公式推导出来了，但是，我记得对数的出现时间是早于指数的，所以肯定有纯对数的推导方式。其实对数推导方式是更加简单的，只要对它习惯就好。 首先告诉自己三遍，对于任何的数 a，都可表示成： $ a=e^{\ln a} $。这里用e为底只是举例，实际上用任何数作为底都可以。 然后有 \log _a b = \log _{e^{\ln a}} e^{\ln b} 对数中的指数是可以提取到log符号左边的，例如上式中，$ln a$ 可提到左边作为分母，$ln b$ 可提到左边作为分子，因此： \log _a b = \log _{e^{\ln a}} e^{\ln b} = \frac{\ln b}{\ln a}\log _e e = \frac{\ln b}{\ln a}]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>对数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[索引基础]]></title>
    <url>%2Fblog%2F%E7%B4%A2%E5%BC%95%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[索引是一种存取结构 1. 主索引、聚簇索引和辅助索引根据字段类型是否码字段，可以有如下第一种索引分类方式： 主索引，如果记录文件使用一码字段进行物理排序，基于此字段建立的索引称作主索引 聚簇索引，如果记录文件使用一个非码字段进行物理排序，该字段称作聚簇字段，基于聚簇字段建立的索引称作聚簇索引 辅助索引，是基于记录的非排序字段建立的索引 由于一个文件最多只能有一个物理排序字段，因此一个文件最多只能有一个主索引或一个聚簇索引；而辅助索引则可有多个。 索引由索引项组成，索引项可表示为&lt;k(i), p(i)&gt;。 在主索引中，k(i)是块锚的索引字段值，p(i)是指向块锚的指针。一条索引项的长度小于一条记录的长度，因此一个磁盘块可存储更多的索引项。 磁盘块是磁盘和主存的数据传输单位。一个磁盘块可有多条记录，块因子 bfr (Blocking Factor) 表示一个磁盘块所拥有的记录数。如果取B为一个磁盘块的容量，R为一条记录所占用的容量，则 $ bfr = \lfloor B/R \rfloor $ 。一个磁盘块的第一条记录称为该块的锚记录，或简称块锚。 由于聚簇字段在记录文件中的取值不唯一，同一个聚簇字段值对应的记录可能需要存放在一个或多个块中。常见的做法是为每一个值预留一个整块（或一个连续的块簇），k(i)取聚簇字段值，p(i)取指向对应块的首条记录的指针。 2. 稠密索引和稀疏索引根据索引项数目和记录数目的比例，可有如下第二种索引分类方式： 稠密索引，每条记录都存在对应的一条索引项 稀疏索引，只有部分记录有对应的索引项 关于主索引，由于在记录文件中只有块锚才存在对应的索引项，所以是稀疏索引。 聚簇索引由于每个聚簇字段值对应一个索引项，而同一个聚簇字段值可能会对应多条记录，所以也是稀疏索引。 辅助索引由于使用无序字段作为索引字段，没法使用记录文件的块锚。如果采用候选码作为索引字段，那必须为每个记录建立一个索引项，此时它是稠密索引。而如果采用非码字段作为索引字段，则索引字段取值不唯一，此时根据实现方式的不同，辅助索引可为稠密索引或稀疏索引。 3. 索引如何提升查询效率如果采用对磁盘快访问次数多少作为衡量查询效率的指标，那么考虑以下例子： 例子1：如果一个磁盘块大小B=1024字节，一个文件包含的记录数r=30000个，每条记录的长度R=100字节，记录定长且不跨块。那么存储该文件所需块数b等于多少，二分查找该文件需进行多少次块访问？ 解：块因子 $ bfr=\lfloor B/R \rfloor = 10 $ 个记录/块存储文件所需块数 $ b=\lceil r/bfr \rceil=3000 $ 块块访问次数=$ \lceil \log _{2} b \rceil = 12 $ 次 例子2：在例子1的基础上，如果有建立主索引，其中码字段长9字节（记做K），块指针长6字节（记做P），那么二分查找该索引文件需进行多少次块访问？ 解：一条索引项长度 $ R_i=K+P=15 $ 字节索引块因子（一个磁盘块可以存储的索引项个数）$ bfr_i = \lfloor B/R_i \rfloor = 68$索引项的总数=记录文件的块数=3000个，因此索引文件所需块数$ b_i = \lceil b/bfr_i \rceil = 45$ 块，块访问次数=$ \lceil \log _{2} b_i \rceil + 1 = 6+1 = 7 $ 次，多出的一次是对记录块的访问。 例子3：如果使用无须字段作为查询字段，直接线性查找记录文件平均需要多少次块访问？如果存在辅助索引，则需要多少次块访问？ 解：直接线性查找记录文件平均需要 $ b/2=1500 $ 次块访问辅助索引的索引项数量 $ r_i = r = 30000 $ 个索引文件所需块数 $ b_i = \lceil r_i/bfr_i \rceil = \lceil 30000/68 \rceil = 442 $ 块块访问次数=$ \lceil \log _{2} b_i \rceil + 1 = 9+1 = 10 $ 次 相比主索引的7次块访问，辅助索引稍差一点，但是比起直接线性查找记录文件所需的平均1500次块访问，辅助索引更显著地减少了对磁盘块的访问次数。]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>数据库理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一元n次方程]]></title>
    <url>%2Fblog%2F%E4%B8%80%E5%85%83n%E6%AC%A1%E6%96%B9%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1. 一元二次方程形如 \(f(x) = ax^2 + bx + c\) 称作一元二次方程，即自变量只有一个，自变量的最高次数为2。 1.1. 根的性质想求 \(f(x) = ax^2 + bx + c = 0\) 的根，有一个思路：先将表达式 \(ax^2 + bx + c = 0\) 转成 \((x+A)^2=B\) 的形式，之后即可得 \(x=\pm \sqrt{B}-A\) 。而 \((x+A)^2 = x^2 + 2Ax + A^2\) ，所以先将 \(ax^2 + bx + c = 0\) 转化成这种形式，推导过程如下：消除二次项系数 x^2 + \frac{b}{a}x + \frac{c}{a} = 0即 x^2 + \frac{b}{a}x = -\frac{c}{a}等号两边同时加项，将左边构造成 \(x^2 + 2Ax + A^2\) 的形式 x^2 + \frac{b}{2a}x\cdot 2 + (\frac{b}{2a})^2 = -\frac{c}{a}-(\frac{b}{2a})^2左边变形，右边同分母相加 (x+\frac{b}{2a})^2 = \frac{-4ac+b^2}{4a^2}求得 x=\pm \sqrt{\frac{b^2-4ac}{4a^2}} - \frac{b}{2a} = \frac{-b\pm\sqrt{b^2-4ac}}{2a}1.2. 抛物线性质由以上结果可知，抛物线基于 \(x=-\frac{b}{2a}\) 对称，将该值代入方程，得原点坐标为 \((-\frac{b}{2a},\frac{-b^2+4ac}{4a})\) 。 1.3. 判别式在根表达式中， \(\Delta = b^2-4ac\) 为判别式，可根据判别式的值大于、等于、小于0的情况，判断方程有两个实根，一个实根还是有两个共轭复根。 2. 韦达定理2.1. 定义如果方程 $f(x) = a_0x^n+a_1x^{n-1}+…+a_{n-1}x+a_n=0$ $(a_0\neq 0)$ 的n个根是 $x_1,x_2,…,x_{n-1},x_n$，那么 \begin{cases} x_1+x_2+\cdot\cdot\cdot+x_n = -\frac{a_1}{a_0},\\ x_1x_2+x_1x_3+\cdot\cdot\cdot+x_{n-1}x_n = \frac{a_2}{a_0},\\ \cdot\cdot\cdot\\ x_1x_2x_3 \cdot\cdot\cdot x_{n-1}x_n = (-1)^n\frac{a_n}{a_0}. \end{cases}2.2. 证明据书上1所说，因为 $x_1, x_2, \cdot\cdot\cdot, x_n$ 是 $f(x)=0$ 的根，所以 $f(x)$ 必定含有n个一次因式：$x-x_1, x-x_2, \cdot\cdot\cdot, x-x_{n-1}, x-x_n$ 并且$f(x) = a_0(x-x_1)(x-x_2) \cdot\cdot\cdot (x-x_{n-1})(x-x_n)$2 把上式右端按照$x$降幂展开得 a_0x^n+a_1x^{n-1}+...+a_{n-1}x+a_n =\\ a_0x^n-a_0(x_1+x_2+\cdot\cdot\cdot+x_n)x^{n-1} \\ +a_0(x_1x_2+x_1x_3+\cdot\cdot\cdot+x_{n-1}x_n)x^{n-2}\\ +\cdot\cdot\cdot+(-1)^na_0x_1x_2x_3\cdot\cdot\cdot x_{n-1}x_n这是一个恒等式，根据多项式恒等定理，得\begin{cases}a_1=-a_0(x_1+x_2+\cdot\cdot\cdot+x_n) \\a_2=-a_0(x_1x_2+x_1x_3+\cdot\cdot\cdot+x_{n-1}x_n) \\\cdot\cdot\cdot \\a_n=(-1)^na_0x_1x_2x_3 \cdot\cdot\cdot x_{n-1}x_n\end{cases} 故定理得证 \begin{cases} x_1+x_2+\cdot\cdot\cdot+x_n = -\frac{a_1}{a_0},\\ x_1x_2+x_1x_3+\cdot\cdot\cdot+x_{n-1}x_n = \frac{a_2}{a_0},\\ \cdot\cdot\cdot\\ x_1x_2x_3 \cdot\cdot\cdot x_{n-1}x_n = (-1)^n\frac{a_n}{a_0}. \end{cases}3. 方程变换3.1. 变换后各个根为原方程各个根的k倍定理：方程 $ f(\frac{y}{k}) = 0 $ 的各个根分别等于方程 $ f(x) = 0 $ 各个根的k倍。证明：设 $ a_i(i=1,2,\cdot\cdot\cdot , n) $ 是方程 $ f(x) = 0 $ 的根，则 $ f(a_i) = f(\frac{ka_i}{k}) = 0 $，所以 $ ka_i(i=1,2,\cdot\cdot\cdot , n) $ 是方程 $ f(\frac{y}{k}) = 0 $ 的根，又因为 $ f(\frac{y}{k}) = 0 $ 只有n个根，故 $ f(\frac{y}{k}) = 0 $ 的各根分别等于 $ f(x) = 0 $ 各根的k倍。 3.2. 变换后各个根为原方程各个根相差k$f(y+k)=0$ 的各个根分别等于方程 $ f(x) = 0 $ 的各个根减去k。 3.3. 变换后各个根为原方程各个根的倒数$f(\frac{1}{y})$ 的各个根分别等于方程 $ f(x) = 0 $ 的各个根的倒数。 3.3.1. 倒根方程如果n次方程 $g(x)$ 的各个根分别是n次方程 $f(x) = a_0x^n+a_1x^{n-1}+…+a_{n-1}x+a_n=0$ 各个根的倒数，那么 $g(x) = a_nx^n+a_{n-1}x^{n-1}+…+a_1x+a_0=0$。 1.《初等数学研究》（主编：叶立军）第3.3节 ↩2.这里我能理解当x取这些根值的其中之一时，等式的左右两边都为0，但我还不明白为啥据此能得出 $f(x)$ 一定有这n个因式，且这条等式（不管x取什么值都）成立，这个问题先放着。 ↩]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式定理]]></title>
    <url>%2Fblog%2F%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. 二项式定理$(a+b)^2$可看成$(a+b)(a+b)$，即两个因式(a+b)相乘。观察它的两次乘法分配率的计算过程： (a+b)(a+b)=a\cdot a+ab+ba+b\cdot b可以这样理解：从两个因式中取出两个a相乘，得$a^2$，共有$C_2^2$个1；然后从两个因式中只取一个a（另一个就只能为b了）相乘，得$ab$，共有$C_2^1$个；最后都取b（即都不取a）相乘，共有$C_2^0$个，所以 (a+b)^2 = C_2^2a^2 + C_2^1ab + C_2^0b^2 = a^2+2ab+b^2 同样的思路： (a+b)^3 = C_3^3a^3 + C_3^2a^2b + C_3^1ab^2 + C_3^0b^3 = a^3+3a^2b+3ab^2+b^3还是同样的思路： (a+b)^n = C_n^na^n + C_n^{n-1}a^{n-1}b+C_n^{n-2}a^{n-2}b^2+\cdot\cdot\cdot+C_n^2a^2b^{n-2}+C_n^1ab^{n-1}+C_n^0b^n可以更简单的记为： (a+b)^n = \sum C_n^ma^mb^{n-m}2. 多项式定理考虑$(a+b+c)^3$，将其展开得 a \cdot a \cdot a + a \cdot a \cdot b + a \cdot a \cdot c + \cdot\cdot\cdot可以看出，展开式的每一项的次数都是3，考虑其中一项：$a \cdot a \cdot b$，这一项是两个a和一个b相乘，那么这样的项有多少个呢？有： aab aba baa 3个。所以将展开式合并同类项后，aab项的系数是3. 然后如何用更一般化的方式表示这个3呢？先将aab看成是a1,a2,b这三个不同的元素，那么它们的全排列有 $a1,a2,b$ $a2,a1,b$ $a1,b,a2$ $a2,b,a1$ $b,a1,a2$ $b,a2,a1$ 一共6个。同时 $a1,a2,b$ $a2,a1,b$ 其实是一样的，剩余4个也是同样的道理，将a1和a2看做同一个元素，它们的排列数就是$6/2$个。这一项是一个a取两次，b取1次的3个不尽相异元素的全排列，数量有$\frac{3!}{2! \cdot 1!}$个。 (a_1+a_2+ \cdot\cdot\cdot + a_m)^n = \sum\limits_{n_1+n_2+ \cdot\cdot\cdot + n_m = n} \frac{n!}{\prod\limits_{i=1}^m n_i!}\prod\limits_{i=1}^m a_i^{n_i}1.这里用到了组合的思想，见排列与组合的基本概念。 ↩]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排列与组合的基本概念]]></title>
    <url>%2Fblog%2F%E6%8E%92%E5%88%97%E4%B8%8E%E7%BB%84%E5%90%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[1. 加法原理做一件事情有m类方法，第一类方法中有$n_1$种方法，第二类方法中有$n_2$种方法……第m类方法中有$n_m$种方法，那么完成这件事情一共有$N=n_1+n_2+ … +n_m$种方法。 2. 乘法原理做一件事情有m个步骤，完成第一步有$n_1$种方法，完成第二步有$n_2$种方法……完成第m步有$n_m$种方法，那么完成这件事情一共有$N=n_1n_2 \cdot\cdot\cdot n_m$种方法。 3. 排列3.1. 不无重复排列从n个不同的元素中，不重复地选取m(m&lt;=n)个元素，按照一定的顺序排成一列，称为从n个不同元素中取m个元素的排列。这样取出的所有排列的个数记作$P_n^m$。 从n个元素中取m个元素，第一次取共有n种选法，第二次取共有n-1种选法，第m次取共有n-m+1种选法，根据乘法原理，有 P_n^m=n(n-1)(n-2)\cdot\cdot\cdot(n-m+1) = \frac{n!}{(n-m)!}规定，$0!=1$，$P_n^0=1$ 3.2. 可重复排列数$R_n^m=n^m$ 3.3. 不尽相异元素的全排列定义：在集合$A=\left \{ a_1,a_2,\cdot\cdot\cdot,a_n \right \}$中可重复选取m个元素。 若$a_i$可重复选取$m_i$次，且$\sum\limits_{i=1}^n m_i=m$，则这样的排列数 B_m=\frac{n!}{\prod\limits_{i=1}^n m_i!}4. 组合从n个不同的元素中，不重复地选取m(m&lt;=n)个元素并成一组，称为从n个不同元素中取m个元素的组合，相对排列而言组合不考虑元素的排列顺序，这种组合的个数记作$C_n^m$。 C_n^m=\frac{P_n^m}{P_m^m}=\frac{m!}{(n-m)!\cdot m!}可得推论： C_n^0=\frac{n!}{n!0!} = 1C_n^n=\frac{n!}{0!n!} = 1]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本博客的搭建与维护日志]]></title>
    <url>%2Fblog%2F%E6%9C%AC%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%BB%B4%E6%8A%A4%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[1. 环境的维护1.1. 基本原则数据不依赖容器，数据都放在宿主机里，容器只用于跑hexo程序，容器可以随时销毁并重新创建。 1.2. 本地启动服务以我的mac为例，启动Docker后，打开终端查看容器，启动容器，进入容器，启动hexo服务： 12345678910111213zhaoyi$ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES8616395cc9ba zhaoyi/hexo-export "/bin/bash" 7 months ago Exited (255) 3 months ago 0.0.0.0:80-&gt;80/tcp, 0.0.0.0:4000-&gt;4000/tcp hexozhaoyi$ docker start hexohexozhaoyi$ docker exec -it hexo /bin/bashroot@8616395cc9ba:/# cd /usr/share/nginx/html/root@8616395cc9ba:/usr/share/nginx/html# ls50x.html _config.yml db.json index.html node_modules package-lock.json package.json public scaffolds source themesroot@8616395cc9ba:/usr/share/nginx/html# hexo s(node:39) [DEP0061] DeprecationWarning: fs.SyncWriteStream is deprecated.INFO Start processingINFO Hexo is running at http://0.0.0.0:4000/blog/. Press Ctrl+C to stop. 此时在（宿主机）浏览器输入 http://localhost:4000/blog 即可看到效果。 编辑文章，保存.md文件后，可自动本地发布。 需要发布到Github Page时，可在原来的终端窗口按下 Command+T 打开一个新页签，输入发布命令，发布过程中会提示输入Github的账号和密码：12345678910zhaoyi$ docker exec -it hexo hexo --cwd /usr/share/nginx/html g -d(node:79) [DEP0061] DeprecationWarning: fs.SyncWriteStream is deprecated.INFO Start processing...Username for 'https://github.com': ........Password for 'https://cyclonezhao@github.com': To https://github.com/cyclonezhao/blog 9968c53..73aa262 HEAD -&gt; gh-pagesBranch master set up to track remote branch gh-pages from https://github.com/cyclonezhao/blog.INFO Deploy done: git 2. 维护日志(2018)2.1. 20180727 初始搭建 下载docker镜像并运行，容器起名为 hexo，指定宿主机与容器的文件映射和端口映射；PS：镜像和容器的关系就好比类与对象的关系 1sudo docker run --name hexo -it -p 80:80 -v /home/kduser/hexo/source:/usr/share/nginx/html/source simplyintricate/hexo 初始化，生成网站的一些静态文件；此处创建的文章《New Post》并不重要，仅是为了通过此命令生成初始的静态文件，这个文章后续删除掉即可 1sudo docker exec -it hexo hexo new "New Post" 该命令具有重新刷新的作用，即根据文章.md文件生成html文件 1sudo docker exec -it hexo hexo generate 将容器除source目录以外的其余部分拷贝到宿主机 123456789101112host="hexo:/usr/share/nginx/html"dest="/home/kduser/hexo"docker cp $&#123;host&#125;/50x.html $&#123;dest&#125;/docker cp $&#123;host&#125;/db.json $&#123;dest&#125;/docker cp $&#123;host&#125;/index.html $&#123;dest&#125;/docker cp $&#123;host&#125;/node_modules $&#123;dest&#125;/docker cp $&#123;host&#125;/package.json $&#123;dest&#125;/docker cp $&#123;host&#125;/public $&#123;dest&#125;/docker cp $&#123;host&#125;/scaffolds $&#123;dest&#125;/docker cp $&#123;host&#125;/themes $&#123;dest&#125;/docker cp $&#123;host&#125;/_config.yml $&#123;dest&#125;/ 2.2. 20180801 更换Next样式 从网上下载样式，解压到themes目录，并更名为next 修改_config.yml，增加配置：theme: next 2.3. 20180810 修改源码修改node_modules\hexo\lib\plugins\generator\page.js，增加以下代码，使得prototype目录下的内容不被hexo处理，原封不动地拷贝到public运行时目录。prototype目录用于放置产品原型html1234567891011var path = page.path;var notRender = ["prototype"]; // 设置不被 render 的目录var dir = path.substring(0, path.indexOf('/'));if (!layout || layout === 'false' || layout === 'off' || (notRender.indexOf(dir) &gt; -1)) &#123; return &#123; path: path, data: page.content &#125;;&#125; 2.4. 20180815 关闭动画效果修改/themes/next/_config.yml，将motion的enable设置为false 2.5. 20180818 修改源码修改node_modules\hexo\lib\plugins\generator\page.js，将20180810的修改内容改为如下：12345678var notRender = []; // 设置不被 render 的目录if(self.config.no_render)&#123; notRender = self.config.no_render.split(",");&#125;var dir = path.substring(0, path.indexOf('/'));if (!layout || layout === 'false' || layout === 'off' || (notRender.indexOf(dir) &gt; -1)) &#123; 然后修改全局的_config_yml，增加：12# 不被渲染的文件或文件夹，用,分隔no_render: prototype 本来想使用hexo-processor-copyassets插件，可惜没效果。 2.6. 20180823 修改npm源，安装hexo-footnotes插件，支持注脚，重新制作镜像修改npm源的原因是内网无法发送https请求，所以用了一个非https的源。123npm config set registry http://registry.npmjs.orgnpm config list #查看更新后的config设置npm install hexo-footnotes --save # 安装插件 尝试安装以下两个插件： hexo-heading-index，标题自动加序号 hexo-generator-searchdb，文章搜索 在外网尝试安装后，执行hexo g会报错，于是上网搜索解决方案，执行以下命令后，问题解决。123sudo npm cache clean -fsudo npm install -g nsudo n stable 但是内网执行n stable会失败，估计又是网络问题。于是尝试将外网的容器迁移到内网来，在外网机器执行命令，将容器打成.tar压缩包：1docker export -o hexo-export.tar hexo 将压缩包拷到内网后，执行命令，将压缩包转化成镜像。1docker import ./hexo-export.tar zhaoyi/hexo-export 完后，执行命令生成容器1sudo docker run --name hexo -it -p 80:80 -p 4000:4000 -v /Users/zhaoyi/Documents/GitHub/hexo/source:/usr/share/nginx/html/source zhaoyi/hexo-export /bin/bash 这里出现了和以前不一样的地方，执行上述命令后会自动进入容器，但只进入根目录，而不是像之前那样能直接进入/usr/share/nginx/html目录。上网查了下资料，可以用以下命令查看之前镜像的一些信息，但只了解到这里而已。1docker inspect simplyintricate/hexo:latest 执行以下命令启动服务，这时不能按ctrl+c退出服务，只能将终端关闭重来1hexo generate &amp;&amp; nginx -g "daemon off;" 内容变更后重新生成网站，要指定-cwd1hexo --cwd /usr/share/nginx/html g 由于有了上述两个插件，所以修改/themes/next/_config.yml，关闭右侧大纲视图的序号输出，并打开本地搜索功能12345678# Table Of Contents in the Sidebartoc: enable: true # Automatically add list number to toc. number: falselocal_search: enable: true 修改/_config.yml，增加内容1234567# 标题加序号heading_index: enable: true index_styles: "&#123;1&#125; &#123;1&#125; &#123;1&#125; &#123;1&#125; &#123;1&#125; &#123;1&#125;" connector: "." global_prefix: "" global_suffix: ". " 2.7. 20180824 超链接样式修改成蓝色在主题配置文件themes/next/_config.yml，新增配置项：123456custom_css: # the style of post body link post_body_a: enable: true normal_color: "#0593d3" hover_color: "#0477ab" next主题提供了用户自定义样式的扩展功能，我们只需要在themes/next/source/css/_custom/custom.styl里添加样式就可以新增或覆盖原来的样式。1234567891011// custom.stylif hexo-config("custom_css.post_body_a.enable") .post-body a&#123; color: convert(hexo-config("custom_css.post_body_a.normal_color")); border-bottom: none; &amp;:hover &#123; color: convert(hexo-config("custom_css.post_body_a.hover_color")); text-decoration: underline; &#125; &#125; 2.8. 20180825 生成tags和categories页按照这里的说明操作即可。按tags为例说明，categories的步骤完全一样： STEP1hexo new page tags STEP2打开 /source/tags/index.md，增加type12345---title: 标签date: 2016-06-08 16:19:38type: "tags"--- STEP3打开 /themes/next/_config.yml，找到menu，打开tags的注释，可能是这样1234567menu: home: / categories: /categories #about: /about archives: /archives tags: /tags #commonweal: /404.html 2.9. 20180826 修改hexo的渲染引擎，以便更好的支持latexhexo在渲染含有下标，大括号的公式时会存在问题，因此参考这篇文章的介绍做了些修改： 替换渲染引擎（先卸载掉旧的，再安装新的）12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save 然后修改node_modules\kramed\lib\rules\inline.js，把第11行的escape变量的值做相应的修改，取消对\,{,}的转义(escape)：12// escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/, escape: /^\\([`*\[\]()#$+\-.!_&gt;])/ 再把第20行的em变量也要做相应的修改。12// em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/ 修改themes/next/_config.yml，将math.per_page属性设为true，以后在需要支持公式的文章中应加上mathjax: true配置。 配置一键发布github按照官方文档配置好后，执行deploy命令，提示需要配置git：12git config --global user.email "you@example.com"git config --global user.name "Your Name" 配置完毕后，由于我的根目录是/blog，所以还要修改/_config.yml的root属性，否则大量文件找不到。完成后，执行hexo g -d，中途会提示输入github的用户名和密码，输入后即可完成发布。 2.10. 20180916 支持代码折叠部分改动这里的做法： 1234567891011121314151617181920212223242526272829303132333435363738// 修改themes/next/source/js/src/motion.js，最后面加上以下代码$(document).ready(function()&#123; $(document).on('click', '.hider_title', function()&#123; $('&gt;.fold', this.parentNode.parentNode).slideToggle(); $('&gt;:first', this.parentNode).toggleClass('open'); &#125;); //默认情况下折叠 $("div.fold").css("display","none");&#125;);// 新增 themes/next/scripts/tags.jsconst rEscapeContent = /&lt;escape(?:[^&gt;]*)&gt;([\s\S]*?)&lt;\/escape&gt;/g;const placeholder = '\uFFFD';const rPlaceholder = /(?:&lt;|&amp;lt;)\!--\uFFFD(\d+)--(?:&gt;|&amp;gt;)/g;const cache = [];function escapeContent(str) &#123; return '&lt;!--' + placeholder + (cache.push(str) - 1) + '--&gt;';&#125;hexo.extend.filter.register('before_post_render', function(data) &#123; data.content = data.content.replace(rEscapeContent, function(match, content) &#123; return escapeContent(content); &#125;); return data;&#125;);hexo.extend.filter.register('after_post_render', function(data) &#123; data.content = data.content.replace(rPlaceholder, function() &#123; return cache[arguments[1]]; &#125;); return data;&#125;);// 新增 themes/next/scripts/fold.jsfunction fold (args, content) &#123; var text = args[0]; if(!text) text = ""; return '&lt;div&gt;&lt;div class="fold_hider"&gt;&lt;a class="close hider_title"&gt;' + text + '&lt;/a&gt;&lt;/div&gt;&lt;div class="fold"&gt;\n' + hexo.render.renderSync(&#123;text: content, engine: 'markdown'&#125;) + '\n&lt;/div&gt;&lt;/div&gt;';&#125;hexo.extend.tag.register('fold', fold, &#123;ends: true&#125;); 1234567891011121314151617/*修改themes/next/source/css/_custom/custom.styl，增加内容*/div.fold&#123; display: none;&#125;.hider_title&#123; font-family: "Microsoft Yahei"; cursor: pointer; &amp;:hover&#123; text-decoration: none; &#125;&#125;.close:after&#123; content: "展开代码";&#125;.open:after&#123; content: "收起代码";&#125;]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
</search>
