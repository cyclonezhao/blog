<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[单变量微积分]]></title>
    <url>%2Fblog%2F%E5%8D%95%E5%8F%98%E9%87%8F%E5%BE%AE%E7%A7%AF%E5%88%86%2F</url>
    <content type="text"><![CDATA[1. 导数 物理意义：瞬时变化率 几何意义：切线斜率 公式：$f’(x)= \lim_{\Delta x \to 0} \frac{\Delta y}{\Delta x} = \lim_{\Delta x \to 0} \frac{f(x+\Delta x) - f(x)}{\Delta x}$ 可导必连续 连续不一定可导 不连续一定不可导 2. 基本求导公式\begin{aligned} {(C)}'&=0\\[1em] x^n &= nx^{n-1}\\[1em] (cu)'&=cu'\\[1em] \end{aligned}3. 和差积商\begin{aligned} {(u\pm v)}'&=u'\pm v'\\[1em] (uv)'&=u'v+uv'\\[1em] (\frac{u}{v})'&=\frac{u'v-uv'}{v^2}\\[1em] \end{aligned}4. 链式法则\frac{\mathrm{d} y}{\mathrm{d} x}=\frac{\mathrm{d} y}{\mathrm{du}}\cdot \frac{\mathrm{d}u}{\mathrm{d}x}5. 高阶导数{u}'',u''',u(4)6. 指数与对数 \begin{aligned} (e^x)'&=e^x\\[1em] (a^x)'&=a^x\ln(a)\\[1em] (\ln{x})&=\frac{1}{x}\\[1em] e&=\lim_{x \to \infty }(1+\frac{1}{x})^x\approx 2.71828 \end{aligned}7. 线性近似与二阶近似 \begin{aligned} f(x) &\approx f(x_0)+f'(x_0)(x-x_0)\\[1em] f(x) &\approx f(x_0)+f'(x_0)(x-x_0)+\frac{f''(x_0)(x-x_0)}{2}\\[1em] f(x) &\approx f(0)+f'(0)(x)\\[1em] f(x) &\approx f(0)+f'(0)(x)+\frac{f''(0)(x)}{2}\\[1em] \end{aligned}8. 曲线构图 概念 取值 条件 性质 凹 凹 f’’(x)&lt;0 切线顺时针旋转 凸 凸 f’’(x)&gt;0 切线逆时针旋转 极值点 (x,y) f’(x)=0 该点左右两侧函数单调性变更 驻点 x f’(x)=0 该点切线斜率为0 驻点值 f(x) f’(x)=0 拐点 x f’’(x)=0 该点左右两侧函数凹凸性变更 无限远端 常数/$\pm \infty$ $x=\pm \infty$ 8.1. 构图步骤一言难尽，凭经验总结如下： 找出奇点，确认奇点两侧的函数值趋向 找出驻点（顺带包含极值点了），并确认驻点值（表明正负性） 找出拐点 找出边界点或无限远端 判定在上述各点所分割的各区间内，函数的单调性，和凹凸性（可选） 凭以上工作所得信息绘制草图 9. 最值问题10. 牛顿迭代法x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}思想： 已知x0很接近真实解x 过点（x0,f(x0))作f(x)的切线，相交x轴于x1 此刻x1肯定是比x0更接近x的值 用x1重复步骤2，3；迭代次数越多，得到的xn越接近真实解x 条件（总体来说，可能只能靠猜）： x0必须足够接近真实解x f’(x0)不能太小（否则得到的x1会比x0更远离x） f’’(x0)不能太大（否则得到的x1会比x0更远离x）]]></content>
      <categories>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[导数的几何解释]]></title>
    <url>%2Fblog%2F%E5%AF%BC%E6%95%B0%E7%9A%84%E5%87%A0%E4%BD%95%E8%A7%A3%E9%87%8A%2F</url>
    <content type="text"><![CDATA[1. 基本概念曲线，切线和斜率曲线f(x)切线斜率f’(x)，称作f在x处的导数，变化率 割线的斜率切线的斜率 $f’(x)=\lim_{\Delta x \to 0}\frac{\Delta f}{\Delta x}$ 符号 f'=\frac{df}{dx}=\frac{dy}{dx}=\frac{d}{dx}f=\frac{d}{dx}y简单极限导数 连续，意味着 \lim_{x \to x_0}f(x)=f(x_0)（函数在某一点处）可导即连续定理 2. 求导公式\frac{d}{dx}x^n=nx^{n-1}(u+v)'=u'+v'(cu)'=cu'(uv)'=u'v+uv'(u/v)'=\frac{u'v-uv'}{v^2}3. 三角函数\frac{d}{dx}sinx=cosx\frac{d}{dx}cosx=-sinx4. 复合函数\frac{dy}{dt}=\frac{dy}{dx}\frac{dx}{dt}5. 隐函数微分(Implicit Differentiation)\frac{d}{dx}(x^2+y^2=1)2x+2yy'= 0y'=-\frac{x}{y}这里，y’的解是带y的，这个方法的好处在于如果能给出一个点(x,y)，就可以快速方便的求出函数在该点处的斜率。知道某函数的导数，求出逆函数导数的方法 6. 指数函数\frac{d}{dx}a^x=\lim_{\Delta x \to 0}a^x \frac{a^{\Delta x} - 1}{\Delta x}将 $\lim_{\Delta x \to 0}\frac{a^{\Delta x} - 1}{\Delta x}$记作$M(a)$，得 \frac{d}{dx}a^x=a^x M(a)当x取0，上式右侧等于M(a)，即函数在x=0处的斜率为M(a)。 定义数字e，使M(e)=1，可知$e^x$的导数为它自身，它在x=0处的斜率为1： \frac{d}{dx}e^x=e^x7. 对数函数(\ln x)'=\frac{1}{x}(a^x)'=(\ln a)a^x(\ln u)'=u'/u(x^x)'=x^x(1+\ln x)推论 \lim_{x \to \infty }(1+\frac{1}{x})=e8. 线性近似(Linear Approximation)f(x)\approx f(x_0)+f'(x_0)(x-x_0)意义：曲线在切点处近似于其切线，上式仅在 $x \approx x_0$ 时成立。 为方便记忆，取$x_0=0$，则有 f(x)\approx f(0)+f'(0)x常用的近似公式($x_0 \approx 0$) \sin x \approx x\cos x \approx 1e^x \approx 1+x\ln (1+x) \approx x(1+x)^r \approx 1+rx9. 二阶近似(Quadratic Approx.)f(x)\approx f(x_0)+f'(x_0)(x-x_0)+\frac{f''(x_0)}{2}(x-x_0)^2取$x_0=0$，有 f(x)\approx f(0)+f'(0)(x)+\frac{f''(0)}{2}x^2为什么二次项的系数是1/2？因为二次函数，即抛物线，它的近似等于它自身；通过求出它的一阶导数，二阶导数，再套入公式，即可得出二次项的系数是1/2，这就是对该公式的解释。 常用的近似公式($x_0 \approx 0$) \sin x \approx x\cos x \approx 1 - \frac{1}{2}x^2e^x \approx 1+x+\frac{1}{2}x^2\ln (1+x) \approx x-\frac{1}{2}x^2(1+x)^r \approx 1+rx+\frac{r(r-1)}{2}x^2二阶导数为负，所以一阶导数递减，所以原函数为 凹函数 (concave down);二阶导数为正，所以一阶导数递增，所以原函数为 凸函数 (concave up); 10. 作图步骤 锚点。找出函数的不连续点，或者是趋于无穷的点；标出无穷远点，即x趋于正负无穷的点；标出容易求出的点（非必需 ） 求出导数为0的点（如果有），标出驻点和其值 判断f’在以上述两步找出的点为端点 的区间内的正负性（可作为前两步的复查手段） 观察f’’ 的正负性，以便判断函数的凹凸性；可以求出f’’=0的点，即 拐点（非必需） 把所有的信息组合起来 11. 最值问题12. 牛顿迭代法求根号5的近似值 13. 中值定理走一段路程，必然存在某一时刻的瞬时速度等于走该段路程的平均速度。 前提条件是函数在a，b范围内可导，且连续。 14. 无穷小量将导数看做dy和dx这两个无穷小量之比 15. 不定积分反导数 $G(x) = \int g(x)dx$ 又称作g的不定积分。例如 $\int \sin x dx = -\cos x + C$，C是任意常数，函数是不确定的，“不定”的含义就在于此。积分的唯一性：if F’=G’ then F(x)=G(x)+C]]></content>
      <categories>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[八皇后问题]]></title>
    <url>%2Fblog%2F%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1. 定义在8*8棋盘上放置8个皇后，使得她们不能互相攻击，问有多少种摆法。 2. 给定一种摆法，列出所有互相攻击的棋子对 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667function willAttack(point1, point2)&#123; return point1.x == point2.x || point2.y == point1.y || (Math.abs(point1.x - point2.x) == Math.abs(point1.y - point2.y));&#125;var pointList = [ &#123;x:0, y:4&#125;, &#123;x:1, y:5&#125;, &#123;x:2, y:6&#125;, &#123;x:3, y:3&#125;, &#123;x:4, y:4&#125;, &#123;x:5, y:5&#125;, &#123;x:6, y:6&#125;, &#123;x:7, y:5&#125;];var result = [];for(var i = 0, len = pointList.length; i &lt; len; i++)&#123; var point1 = pointList[i]; for(var j = i + 1; j &lt; len; j++)&#123; var point2 = pointList[j]; if(willAttack(point1, point2))&#123; result.push([point1, point2]); &#125; &#125;&#125;console.log("count: " + result.length);for(var i in result)&#123; var pair = result[i]; console.log("(%s,%s)-&gt;(%s,%s)", pair[0].x, pair[0].y, pair[1].x, pair[1].y);&#125;/* 输入var pointList = [ &#123;x:0, y:4&#125;, &#123;x:1, y:5&#125;, &#123;x:2, y:6&#125;, &#123;x:3, y:3&#125;, &#123;x:4, y:4&#125;, &#123;x:5, y:5&#125;, &#123;x:6, y:6&#125;, &#123;x:7, y:5&#125;];输出count: 17eight queens:39 (0,4)-&gt;(1,5)eight queens:39 (0,4)-&gt;(2,6)eight queens:39 (0,4)-&gt;(4,4)eight queens:39 (1,5)-&gt;(2,6)eight queens:39 (1,5)-&gt;(3,3)eight queens:39 (1,5)-&gt;(5,5)eight queens:39 (1,5)-&gt;(7,5)eight queens:39 (2,6)-&gt;(4,4)eight queens:39 (2,6)-&gt;(6,6)eight queens:39 (3,3)-&gt;(4,4)eight queens:39 (3,3)-&gt;(5,5)eight queens:39 (3,3)-&gt;(6,6)eight queens:39 (4,4)-&gt;(5,5)eight queens:39 (4,4)-&gt;(6,6)eight queens:39 (5,5)-&gt;(6,6)eight queens:39 (5,5)-&gt;(7,5)eight queens:39 (6,6)-&gt;(7,5)*/]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一元n次方程]]></title>
    <url>%2Fblog%2F%E4%B8%80%E5%85%83n%E6%AC%A1%E6%96%B9%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1. 一元二次方程形如 \(f(x) = ax^2 + bx + c\) 称作一元二次方程，即自变量只有一个，自变量的最高次数为2。 1.1. 根的性质想求 \(f(x) = ax^2 + bx + c = 0\) 的根，有一个思路：先将表达式 \(ax^2 + bx + c = 0\) 转成 \((x+A)^2=B\) 的形式，之后即可得 \(x=\pm \sqrt{B}-A\) 。而 \((x+A)^2 = x^2 + 2Ax + A^2\) ，所以先将 \(ax^2 + bx + c = 0\) 转化成这种形式，推导过程如下：消除二次项系数 x^2 + \frac{b}{a}x + \frac{c}{a} = 0即 x^2 + \frac{b}{a}x = -\frac{c}{a}等号两边同时加项，将左边构造成 \(x^2 + 2Ax + A^2\) 的形式 x^2 + \frac{b}{2a}x\cdot 2 + (\frac{b}{2a})^2 = -\frac{c}{a}-(\frac{b}{2a})^2左边变形，右边同分母相加 (x+\frac{b}{2a})^2 = \frac{-4ac+b^2}{4a^2}求得 x=\pm \sqrt{\frac{b^2-4ac}{4a^2}} - \frac{b}{2a} = \frac{-b\pm\sqrt{b^2-4ac}}{2a}1.2. 抛物线性质由以上结果可知，抛物线基于 \(x=-\frac{b}{2a}\) 对称，将该值代入方程，得原点坐标为 \((-\frac{b}{2a},\frac{-b^2+4ac}{4a})\) 。 1.3. 判别式在根表达式中， \(\Delta = b^2-4ac\) 为判别式，可根据判别式的值大于、等于、小于0的情况，判断方程有两个实根，一个实根还是有两个共轭复根。 2. 韦达定理2.1. 定义如果方程 $f(x) = a_0x^n+a_1x^{n-1}+…+a_{n-1}x+a_n=0$ $(a_0\neq 0)$ 的n个根是 $x_1,x_2,…,x_{n-1},x_n$，那么 \begin{cases} x_1+x_2+\cdot\cdot\cdot+x_n = -\frac{a_1}{a_0},\\ x_1x_2+x_1x_3+\cdot\cdot\cdot+x_{n-1}x_n = \frac{a_2}{a_0},\\ \cdot\cdot\cdot\\ x_1x_2x_3 \cdot\cdot\cdot x_{n-1}x_n = (-1)^n\frac{a_n}{a_0}. \end{cases}2.2. 证明据书上1所说，因为 $x_1, x_2, \cdot\cdot\cdot, x_n$ 是 $f(x)=0$ 的根，所以 $f(x)$ 必定含有n个一次因式：$x-x_1, x-x_2, \cdot\cdot\cdot, x-x_{n-1}, x-x_n$ 并且$f(x) = a_0(x-x_1)(x-x_2) \cdot\cdot\cdot (x-x_{n-1})(x-x_n)$2 把上式右端按照$x$降幂展开得 a_0x^n+a_1x^{n-1}+...+a_{n-1}x+a_n =\\ a_0x^n-a_0(x_1+x_2+\cdot\cdot\cdot+x_n)x^{n-1} \\ +a_0(x_1x_2+x_1x_3+\cdot\cdot\cdot+x_{n-1}x_n)x^{n-2}\\ +\cdot\cdot\cdot+(-1)^na_0x_1x_2x_3\cdot\cdot\cdot x_{n-1}x_n这是一个恒等式，根据多项式恒等定理，得\begin{cases}a_1=-a_0(x_1+x_2+\cdot\cdot\cdot+x_n) \\a_2=-a_0(x_1x_2+x_1x_3+\cdot\cdot\cdot+x_{n-1}x_n) \\\cdot\cdot\cdot \\a_n=(-1)^na_0x_1x_2x_3 \cdot\cdot\cdot x_{n-1}x_n\end{cases} 故定理得证 \begin{cases} x_1+x_2+\cdot\cdot\cdot+x_n = -\frac{a_1}{a_0},\\ x_1x_2+x_1x_3+\cdot\cdot\cdot+x_{n-1}x_n = \frac{a_2}{a_0},\\ \cdot\cdot\cdot\\ x_1x_2x_3 \cdot\cdot\cdot x_{n-1}x_n = (-1)^n\frac{a_n}{a_0}. \end{cases}3. 方程变换3.1. 变换后各个根为原方程各个根的k倍定理：方程 $ f(\frac{y}{k}) = 0 $ 的各个根分别等于方程 $ f(x) = 0 $ 各个根的k倍。证明：设 $ a_i(i=1,2,\cdot\cdot\cdot , n) $ 是方程 $ f(x) = 0 $ 的根，则 $ f(a_i) = f(\frac{ka_i}{k}) = 0 $，所以 $ ka_i(i=1,2,\cdot\cdot\cdot , n) $ 是方程 $ f(\frac{y}{k}) = 0 $ 的根，又因为 $ f(\frac{y}{k}) = 0 $ 只有n个根，故 $ f(\frac{y}{k}) = 0 $ 的各根分别等于 $ f(x) = 0 $ 各根的k倍。 3.2. 变换后各个根为原方程各个根相差k$f(y+k)=0$ 的各个根分别等于方程 $ f(x) = 0 $ 的各个根减去k。 3.3. 变换后各个根为原方程各个根的倒数$f(\frac{1}{y})$ 的各个根分别等于方程 $ f(x) = 0 $ 的各个根的倒数。 3.3.1. 倒根方程如果n次方程 $g(x)$ 的各个根分别是n次方程 $f(x) = a_0x^n+a_1x^{n-1}+…+a_{n-1}x+a_n=0$ 各个根的倒数，那么 $g(x) = a_nx^n+a_{n-1}x^{n-1}+…+a_1x+a_0=0$。 1.《初等数学研究》（主编：叶立军）第3.3节 ↩2.这里我能理解当x取这些根值的其中之一时，等式的左右两边都为0，但我还不明白为啥据此能得出 $f(x)$ 一定有这n个因式，且这条等式（不管x取什么值都）成立，这个问题先放着。 ↩]]></content>
      <categories>
        <category>数学</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03-通过搜索进行问题求解]]></title>
    <url>%2Fblog%2F03-%E9%80%9A%E8%BF%87%E6%90%9C%E7%B4%A2%E8%BF%9B%E8%A1%8C%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1. 搜索为达到目标，寻找行动序列的过程被称为搜索。搜索算法的输入是问题，输出是问题的解，以行动序列的形式返回问题的解。 下图是搜索算法的一般描述。搜索算法的结构大多如此，区别主要在如何选择将要扩展的状态，即 搜索策略。 2. 问题形式化一个问题可以用5个组成部分形式化描述： Agent的初始状态 Agent的可能行动，ACTIONS(s)返回在状态s下可以执行的动作集合。 转移模型，RESULT(s, a)返回在状态s下执行a后达到的状态。 目标测试，测试给定的状态是不是目标状态。 路径耗散函数为每条路径赋一个耗散值。 初始状态、行动和转移模型定义了问题的 状态空间，即从初始状态可以达到的所有状态的集合。状态空间形成一个有向图，其中结点表示状态，弧表示行动。 3. 结点 对应状态空间中的状态 父结点 父结点生成该结点时所采取的行动 代价，指从初始状态到达该结点的路径消耗 4. 评价算法性能考虑四个方面： 完备性 最优性 时间复杂度 空间复杂度 其中，复杂度由3个量表达： b，分支因子，任何节点的最多后继数 d，目标节点所在的最浅深度 m，状态空间中任何路径的最大长度 时间由搜索过程中产生的节点数目度量 空间由内存中存储的最多节点数来度量 5. 无信息搜索策略定义：除了问题定义中提供的状态信息外，没有附加信息。搜索策略按节点扩展的次序分类。 宽度优先搜索 一致代价搜索(uniform-cost search) 深度优先搜索 6. 启发式搜索策略最佳优先搜索结点基于评价函数f(n)被选择扩展评估值最低的结点被选择首先扩展大多数算法的f由启发函数构成启发函数h(n)=结点n到目标的最小代价路径的估计值若n是目标，则h(n)=0 6.1. 贪婪最佳优先搜索试图扩展“离目标最近”的结点，f(n)=h(n)直线距离启发式，h_SLD(state) 6.2. A*g(n)=到达此结点已花费的代价h(n)=从该结点到目标所话代价的估计值f(n)=g(n)+h(n) 保障最优性的条件一h(n)是可采纳的启发式可采纳：不过高估计到达目标的代价 保障最优性的条件二：一致性h(n)&lt;= c(n,a,n’)+h(n’)三角不等式 6.3. 存储受限的启发式搜索迭代加深A(IDA)算法截断值是f代价 递归最佳优先搜索（RBFS）MA 内存受限ASMA 简化的MA 6.4. Agent学习如果更好的搜索元状态空间 程序的内部计算状态目标层状态空间]]></content>
      <categories>
        <category>AI</category>
        <category>《人工智能 - 一种现代的方法》笔记</category>
      </categories>
      <tags>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02-智能Agent]]></title>
    <url>%2Fblog%2F02-%E6%99%BA%E8%83%BDAgent%2F</url>
    <content type="text"><![CDATA[1. Agent与环境传感器从环境接收感知序列，Agent函数将感知序列转化为行动序列，执行器执行行动序列。 2. 理性理性涉及以下4个方面： 性能度量 Agent对环境的先验知识 Agent可以完成的行动 Agent截止到此时的感知序列 3. 任务环境3.1. 任务环境的规范描述，即PEAS描述： 性能 环境 执行器 传感器 例如，出租车任务环境的PEAS描述如下： 性能度量：到达正确的目的地，油量消耗、耗时或费用最小化…… 驾驶环境：各种各样的道路、路上的车辆、行人…… 执行器：油门、刹车、显示或语音输出…… 传感器：摄像头、红外或声呐、GPS…… 3.2. 任务环境的性质 完全可观察的和部分可观察的 单Agent和多Agent 确定的和随机的 片段式的和延续式的：检验次品零件、下棋 静态的和动态的：填字谜游戏、自动驾驶 离散的和连续的：国际象棋、自动驾驶 已知的和未知的：指的是Agent的知识状态 4. Agent程序4种基本的Agent程序： 简单反射Agent 基于模型的反射Agent 基于目标的Agent 基于效用的Agent 4.1. 学习Agent学习Agent划分为4个概念上的组件： 学习元件：负责改进提高 性能元件：负责选择外部行动，是前文考虑的整个Agent。 评判元件 问题产生器 学习元件的设计很大程度上依赖性能元件的设计，“Agent一旦学会了这个技能，需要何种性能元件行驶该能力”？ 评判元件根据固定的性能标准告诉学习元件Agent的运转情况，负责指出Agent的成功程度。应该把性能标准置于Agent之外考虑，理由是Agent不应该修改性能标准来适应自身行为。 问题产生器负责建议探索性行动。如果性能元件自行其是，它会一直根据已知的知识采取最佳的行动。但是，如果Agent可以进行少量探索，做一些短期内可能次优的行动，那么它也许会发现对长期而言更好的行动。 5. 状态表达方式表达力强的方式能表达的信息更多，但也更复杂。]]></content>
      <categories>
        <category>AI</category>
        <category>《人工智能 - 一种现代的方法》笔记</category>
      </categories>
      <tags>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式定理]]></title>
    <url>%2Fblog%2F%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. 二项式定理$(a+b)^2$可看成$(a+b)(a+b)$，即两个因式(a+b)相乘。观察它的两次乘法分配率的计算过程： (a+b)(a+b)=a\cdot a+ab+ba+b\cdot b可以这样理解：从两个因式中取出两个a相乘，得$a^2$，共有$C_2^2$个1；然后从两个因式中只取一个a（另一个就只能为b了）相乘，得$ab$，共有$C_2^1$个；最后都取b（即都不取a）相乘，共有$C_2^0$个，所以 (a+b)^2 = C_2^2a^2 + C_2^1ab + C_2^0b^2 = a^2+2ab+b^2 同样的思路： (a+b)^3 = C_3^3a^3 + C_3^2a^2b + C_3^1ab^2 + C_3^0b^3 = a^3+3a^2b+3ab^2+b^3还是同样的思路： (a+b)^n = C_n^na^n + C_n^{n-1}a^{n-1}b+C_n^{n-2}a^{n-2}b^2+\cdot\cdot\cdot+C_n^2a^2b^{n-2}+C_n^1ab^{n-1}+C_n^0b^n可以更简单的记为： (a+b)^n = \sum C_n^ma^mb^{n-m}2. 多项式定理考虑$(a+b+c)^3$，将其展开得 a \cdot a \cdot a + a \cdot a \cdot b + a \cdot a \cdot c + \cdot\cdot\cdot可以看出，展开式的每一项的次数都是3，考虑其中一项：$a \cdot a \cdot b$，这一项是两个a和一个b相乘，那么这样的项有多少个呢？有： aab aba baa 3个。所以将展开式合并同类项后，aab项的系数是3. 然后如何用更一般化的方式表示这个3呢？先将aab看成是a1,a2,b这三个不同的元素，那么它们的全排列有 $a1,a2,b$ $a2,a1,b$ $a1,b,a2$ $a2,b,a1$ $b,a1,a2$ $b,a2,a1$ 一共6个。同时 $a1,a2,b$ $a2,a1,b$ 其实是一样的，剩余4个也是同样的道理，将a1和a2看做同一个元素，它们的排列数就是$6/2$个。这一项是一个a取两次，b取1次的3个不尽相异元素的全排列，数量有$\frac{3!}{2! \cdot 1!}$个。 (a_1+a_2+ \cdot\cdot\cdot + a_m)^n = \sum\limits_{n_1+n_2+ \cdot\cdot\cdot + n_m = n} \frac{n!}{\prod\limits_{i=1}^m n_i!}\prod\limits_{i=1}^m a_i^{n_i}1.这里用到了组合的思想，见排列与组合的基本概念。 ↩]]></content>
      <categories>
        <category>数学</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排列与组合的基本概念]]></title>
    <url>%2Fblog%2F%E6%8E%92%E5%88%97%E4%B8%8E%E7%BB%84%E5%90%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[1. 加法原理做一件事情有m类方法，第一类方法中有$n_1$种方法，第二类方法中有$n_2$种方法……第m类方法中有$n_m$种方法，那么完成这件事情一共有$N=n_1+n_2+ … +n_m$种方法。 2. 乘法原理做一件事情有m个步骤，完成第一步有$n_1$种方法，完成第二步有$n_2$种方法……完成第m步有$n_m$种方法，那么完成这件事情一共有$N=n_1n_2 \cdot\cdot\cdot n_m$种方法。 3. 排列3.1. 不无重复排列从n个不同的元素中，不重复地选取m(m&lt;=n)个元素，按照一定的顺序排成一列，称为从n个不同元素中取m个元素的排列。这样取出的所有排列的个数记作$P_n^m$。 从n个元素中取m个元素，第一次取共有n种选法，第二次取共有n-1种选法，第m次取共有n-m+1种选法，根据乘法原理，有 P_n^m=n(n-1)(n-2)\cdot\cdot\cdot(n-m+1) = \frac{n!}{(n-m)!}规定，$0!=1$，$P_n^0=1$ 3.2. 可重复排列数$R_n^m=n^m$ 3.3. 不尽相异元素的全排列定义：在集合$A=\left \{ a_1,a_2,\cdot\cdot\cdot,a_n \right \}$中可重复选取m个元素。 若$a_i$可重复选取$m_i$次，且$\sum\limits_{i=1}^n m_i=m$，则这样的排列数 B_m=\frac{n!}{\prod\limits_{i=1}^n m_i!}4. 组合从n个不同的元素中，不重复地选取m(m&lt;=n)个元素并成一组，称为从n个不同元素中取m个元素的组合，相对排列而言组合不考虑元素的排列顺序，这种组合的个数记作$C_n^m$。 C_n^m=\frac{P_n^m}{P_m^m}=\frac{m!}{(n-m)!\cdot m!}可得推论： C_n^0=\frac{n!}{n!0!} = 1C_n^n=\frac{n!}{0!n!} = 1]]></content>
      <categories>
        <category>数学</category>
        <category>排列与组合</category>
      </categories>
      <tags>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本博客的搭建与维护日志]]></title>
    <url>%2Fblog%2F%E6%9C%AC%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%BB%B4%E6%8A%A4%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[1. 环境的维护1.1. 基本原则数据不依赖容器，数据都放在宿主机里，容器只用于跑hexo程序，容器可以随时销毁并重新创建。 1.2. 本地启动服务以我的mac为例，启动Docker后，打开终端查看容器，启动容器，进入容器，启动hexo服务： 12345678910111213zhaoyi$ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES8616395cc9ba zhaoyi/hexo-export "/bin/bash" 7 months ago Exited (255) 3 months ago 0.0.0.0:80-&gt;80/tcp, 0.0.0.0:4000-&gt;4000/tcp hexozhaoyi$ docker start hexohexozhaoyi$ docker exec -it hexo /bin/bashroot@8616395cc9ba:/# cd /usr/share/nginx/html/root@8616395cc9ba:/usr/share/nginx/html# ls50x.html _config.yml db.json index.html node_modules package-lock.json package.json public scaffolds source themesroot@8616395cc9ba:/usr/share/nginx/html# hexo s(node:39) [DEP0061] DeprecationWarning: fs.SyncWriteStream is deprecated.INFO Start processingINFO Hexo is running at http://0.0.0.0:4000/blog/. Press Ctrl+C to stop. 此时在（宿主机）浏览器输入 http://localhost:4000/blog 即可看到效果。 编辑文章，保存.md文件后，可自动本地发布。 2. 维护日志2.1. 20180727 初始搭建 下载docker镜像并运行，容器起名为 hexo，指定宿主机与容器的文件映射和端口映射；PS：镜像和容器的关系就好比类与对象的关系 1sudo docker run --name hexo -it -p 80:80 -v /home/kduser/hexo/source:/usr/share/nginx/html/source simplyintricate/hexo 初始化，生成网站的一些静态文件；此处创建的文章《New Post》并不重要，仅是为了通过此命令生成初始的静态文件，这个文章后续删除掉即可 1sudo docker exec -it hexo hexo new "New Post" 该命令具有重新刷新的作用，即根据文章.md文件生成html文件 1sudo docker exec -it hexo hexo generate 将容器除source目录以外的其余部分拷贝到宿主机 123456789101112host="hexo:/usr/share/nginx/html"dest="/home/kduser/hexo"docker cp $&#123;host&#125;/50x.html $&#123;dest&#125;/docker cp $&#123;host&#125;/db.json $&#123;dest&#125;/docker cp $&#123;host&#125;/index.html $&#123;dest&#125;/docker cp $&#123;host&#125;/node_modules $&#123;dest&#125;/docker cp $&#123;host&#125;/package.json $&#123;dest&#125;/docker cp $&#123;host&#125;/public $&#123;dest&#125;/docker cp $&#123;host&#125;/scaffolds $&#123;dest&#125;/docker cp $&#123;host&#125;/themes $&#123;dest&#125;/docker cp $&#123;host&#125;/_config.yml $&#123;dest&#125;/ 2.2. 20180801 更换Next样式 从网上下载样式，解压到themes目录，并更名为next 修改_config.yml，增加配置：theme: next 2.3. 20180810 修改源码修改node_modules\hexo\lib\plugins\generator\page.js，增加以下代码，使得prototype目录下的内容不被hexo处理，原封不动地拷贝到public运行时目录。prototype目录用于放置产品原型html1234567891011var path = page.path;var notRender = ["prototype"]; // 设置不被 render 的目录var dir = path.substring(0, path.indexOf('/'));if (!layout || layout === 'false' || layout === 'off' || (notRender.indexOf(dir) &gt; -1)) &#123; return &#123; path: path, data: page.content &#125;;&#125; 2.4. 20180815 关闭动画效果修改/themes/next/_config.yml，将motion的enable设置为false 2.5. 20180818 修改源码修改node_modules\hexo\lib\plugins\generator\page.js，将20180810的修改内容改为如下：12345678var notRender = []; // 设置不被 render 的目录if(self.config.no_render)&#123; notRender = self.config.no_render.split(",");&#125;var dir = path.substring(0, path.indexOf('/'));if (!layout || layout === 'false' || layout === 'off' || (notRender.indexOf(dir) &gt; -1)) &#123; 然后修改全局的_config_yml，增加：12# 不被渲染的文件或文件夹，用,分隔no_render: prototype 本来想使用hexo-processor-copyassets插件，可惜没效果。 2.6. 20180823 修改npm源，安装hexo-footnotes插件，支持注脚，重新制作镜像修改npm源的原因是内网无法发送https请求，所以用了一个非https的源。123npm config set registry http://registry.npmjs.orgnpm config list #查看更新后的config设置npm install hexo-footnotes --save # 安装插件 尝试安装以下两个插件： hexo-heading-index，标题自动加序号 hexo-generator-searchdb，文章搜索 在外网尝试安装后，执行hexo g会报错，于是上网搜索解决方案，执行以下命令后，问题解决。123sudo npm cache clean -fsudo npm install -g nsudo n stable 但是内网执行n stable会失败，估计又是网络问题。于是尝试将外网的容器迁移到内网来，在外网机器执行命令，将容器打成.tar压缩包：1docker export -o hexo-export.tar hexo 将压缩包拷到内网后，执行命令，将压缩包转化成镜像。1docker import ./hexo-export.tar zhaoyi/hexo-export 完后，执行命令生成容器1sudo docker run --name hexo -it -p 80:80 -p 4000:4000 -v /Users/zhaoyi/Documents/GitHub/hexo/source:/usr/share/nginx/html/source zhaoyi/hexo-export /bin/bash 这里出现了和以前不一样的地方，执行上述命令后会自动进入容器，但只进入根目录，而不是像之前那样能直接进入/usr/share/nginx/html目录。上网查了下资料，可以用以下命令查看之前镜像的一些信息，但只了解到这里而已。1docker inspect simplyintricate/hexo:latest 执行以下命令启动服务，这时不能按ctrl+c退出服务，只能将终端关闭重来1hexo generate &amp;&amp; nginx -g "daemon off;" 内容变更后重新生成网站，要指定-cwd1hexo --cwd /usr/share/nginx/html g 由于有了上述两个插件，所以修改/themes/next/_config.yml，关闭右侧大纲视图的序号输出，并打开本地搜索功能12345678# Table Of Contents in the Sidebartoc: enable: true # Automatically add list number to toc. number: falselocal_search: enable: true 修改/_config.yml，增加内容1234567# 标题加序号heading_index: enable: true index_styles: "&#123;1&#125; &#123;1&#125; &#123;1&#125; &#123;1&#125; &#123;1&#125; &#123;1&#125;" connector: "." global_prefix: "" global_suffix: ". " 2.7. 20180824 超链接样式修改成蓝色在主题配置文件themes/next/_config.yml，新增配置项：123456custom_css: # the style of post body link post_body_a: enable: true normal_color: "#0593d3" hover_color: "#0477ab" next主题提供了用户自定义样式的扩展功能，我们只需要在themes/next/source/css/_custom/custom.styl里添加样式就可以新增或覆盖原来的样式。1234567891011// custom.stylif hexo-config("custom_css.post_body_a.enable") .post-body a&#123; color: convert(hexo-config("custom_css.post_body_a.normal_color")); border-bottom: none; &amp;:hover &#123; color: convert(hexo-config("custom_css.post_body_a.hover_color")); text-decoration: underline; &#125; &#125; 2.8. 20180825 生成tags和categories页按照这里的说明操作即可。按tags为例说明，categories的步骤完全一样： STEP1hexo new page tags STEP2打开 /source/tags/index.md，增加type12345---title: 标签date: 2016-06-08 16:19:38type: "tags"--- STEP3打开 /themes/next/_config.yml，找到menu，打开tags的注释，可能是这样1234567menu: home: / categories: /categories #about: /about archives: /archives tags: /tags #commonweal: /404.html 2.9. 20180826 修改hexo的渲染引擎，以便更好的支持latexhexo在渲染含有下标，大括号的公式时会存在问题，因此参考这篇文章的介绍做了些修改： 替换渲染引擎（先卸载掉旧的，再安装新的）12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save 然后修改node_modules\kramed\lib\rules\inline.js，把第11行的escape变量的值做相应的修改，取消对\,{,}的转义(escape)：12// escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/, escape: /^\\([`*\[\]()#$+\-.!_&gt;])/ 再把第20行的em变量也要做相应的修改。12// em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/ 修改themes/next/_config.yml，将math.per_page属性设为true，以后在需要支持公式的文章中应加上mathjax: true配置。 配置一键发布github按照官方文档配置好后，执行deploy命令，提示需要配置git：12git config --global user.email "you@example.com"git config --global user.name "Your Name" 配置完毕后，由于我的根目录是/blog，所以还要修改/_config.yml的root属性，否则大量文件找不到。完成后，执行hexo g -d，中途会提示输入github的用户名和密码，输入后即可完成发布。 2.10. 20180916 支持代码折叠部分改动这里的做法： 1234567891011121314151617181920212223242526272829303132333435363738// 修改themes/next/source/js/src/motion.js，最后面加上以下代码$(document).ready(function()&#123; $(document).on('click', '.hider_title', function()&#123; $('&gt;.fold', this.parentNode.parentNode).slideToggle(); $('&gt;:first', this.parentNode).toggleClass('open'); &#125;); //默认情况下折叠 $("div.fold").css("display","none");&#125;);// 新增 themes/next/scripts/tags.jsconst rEscapeContent = /&lt;escape(?:[^&gt;]*)&gt;([\s\S]*?)&lt;\/escape&gt;/g;const placeholder = '\uFFFD';const rPlaceholder = /(?:&lt;|&amp;lt;)\!--\uFFFD(\d+)--(?:&gt;|&amp;gt;)/g;const cache = [];function escapeContent(str) &#123; return '&lt;!--' + placeholder + (cache.push(str) - 1) + '--&gt;';&#125;hexo.extend.filter.register('before_post_render', function(data) &#123; data.content = data.content.replace(rEscapeContent, function(match, content) &#123; return escapeContent(content); &#125;); return data;&#125;);hexo.extend.filter.register('after_post_render', function(data) &#123; data.content = data.content.replace(rPlaceholder, function() &#123; return cache[arguments[1]]; &#125;); return data;&#125;);// 新增 themes/next/scripts/fold.jsfunction fold (args, content) &#123; var text = args[0]; if(!text) text = ""; return '&lt;div&gt;&lt;div class="fold_hider"&gt;&lt;a class="close hider_title"&gt;' + text + '&lt;/a&gt;&lt;/div&gt;&lt;div class="fold"&gt;\n' + hexo.render.renderSync(&#123;text: content, engine: 'markdown'&#125;) + '\n&lt;/div&gt;&lt;/div&gt;';&#125;hexo.extend.tag.register('fold', fold, &#123;ends: true&#125;); 1234567891011121314151617/*修改themes/next/source/css/_custom/custom.styl，增加内容*/div.fold&#123; display: none;&#125;.hider_title&#123; font-family: "Microsoft Yahei"; cursor: pointer; &amp;:hover&#123; text-decoration: none; &#125;&#125;.close:after&#123; content: "展开代码";&#125;.open:after&#123; content: "收起代码";&#125;]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>备忘</tag>
      </tags>
  </entry>
</search>
